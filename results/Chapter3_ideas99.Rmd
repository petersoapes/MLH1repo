---
title: "Chapter3_ideas"
author: "April Peterson"
date: "`r format(Sys.time(), '%d %B %Y')`"
output: html_document
---

```{r setup, include=FALSE}
#load biv data
#load MLH1 data
library(dplyr)
library(plyr)
library(ggplot2)
library(reshape2)
library(raster) #cv

source("~./MLH1repo/src/CommonFunc_MLH1repo.R")

#read files
whole.cell.data <- read.csv("~./MLH1repo/whole_cell_measures.csv")

#load(file="C:/Users/alpeterson7/Documents/MLH1repo/data/MLH1/MLH1_data_setup_1.5.20.RData")#added batch18
#load(file="~./MLH1repo/data/CleanBivData.RData")#added batch17
```


# Within Nuc covariation

Main take away from Wang et al 2019 is that chromosomes with the same nucleus co-vary in number of crossovers. Axis lengths / SC lengths show the same pattern and is known to be regulated at the cell wide level. The authors suggest that the within nucleus co-variation in CO per chromosome is mediated through cell wide regulation of SC area. (the lengths of SC for chromosomes within a cell a correlated, there is more area for COs).

human Data used in the paper

Gruhn et al 2013 - T. Hassold,
4660 prophase sperm from 56 biopsies, 2000 prophase oocytes

Sun et al 2006 --  F. Sun, 824 MLH1 FISH spreads(~100 cells / 10 men)

Oliver-Bonet et al 2007 -- Oliver-
Bonet  (RPA foci for 5 different SCs ~50 cells, ~400 cells with FISH + MLH1). problem if these data are included in big dataset

Lian et al 2008 - S. Xie, (maybe similar data as sun et al 2008?)
Lian, Jie, et al. "Variation in crossover interference levels on individual chromosomes from human males." Human molecular genetics 17.17 (2008): 2583-2594.

Lu et al 2012 - 
Hou et al 2013 - no SC lengths, (CO sounts 68 cells (oocytes?))

Human data are from mulitple citations; Gruhn et al 2013, Sun et al 2006, Oliver-Bonet et al 2007, Lian et al 2008, Lu et al 2012, Hou et al 2013.


Cytological Studies of Human Meiosis: Sex-Specific
Differences in Recombination Originate at, or Prior to,
Establishment of Double-Strand Breaks

Was there original CO position data for this human data? (MLH1 spreads) (there is axis length and CO count per chrm -- this should mean there is position )

```{r human.male.data, echo=FALSE}
#read files
Hs.male_axis <- read.csv("~./MLH1repo/data/Human_male_axis_length.csv", header = TRUE)
#I assume that the rows of MLH1 and SC lengths are the linked observations, check or verify this assumption
#if they are using within cell -- they must

#melt DF -- how do I keep row.name info?
Melted.Hs.male_axis <- melt(Hs.male_axis, 
                            c("row.name", "chr1","chr2","chr3",  "chr4",  "chr5",  "chr6",  "chr7",  "chr8",  "chr9",  "chr10", "chr11", "chr12", "chr13", "chr14", "chr15", "chr16", "chr17", "chr18", "chr19", "chr20", "chr21", "chr22"), 
                         id=c("row.name") )
#remove the first part with of data frame, variable = "row.name""

#clean up dm1 (there are a bunch of rows without useful information)
Melted.Hs.male_axis <- Melted.Hs.male_axis[(!is.na(Melted.Hs.male_axis$value)),]
Melted.Hs.male_axis <- Melted.Hs.male_axis[((Melted.Hs.male_axis$variable != "row.name")),]

colnames(Melted.Hs.male_axis) <- c("row.name", "Chrm.id", "axis.length")

#Seems like there is an outlier, 
Melted.Hs.male_axis <- Melted.Hs.male_axis[(Melted.Hs.male_axis$axis.length < 700 ),]

hs.sc.length_plot <- ggplot(Melted.Hs.male_axis, aes(y=axis.length, x=Chrm.id))+geom_jitter(aes( color=row.name, alpha = .2))+geom_boxplot()+ 
  ggtitle("Human male SC Lengths")+theme(legend.position="none")
hs.sc.length_plot


#### .. Hs.male_MLH1
Hs.male_MLH1 <- read.csv("~./MLH1repo/data/Human_male_MLH1.csv", header = TRUE)

Melted.Hs.male_MLH1 <- melt(Hs.male_MLH1, 
                            c("row.name", "chr1","chr2","chr3",  "chr4",  "chr5",  "chr6",  "chr7",  "chr8",  "chr9",  "chr10", "chr11", "chr12", "chr13", "chr14", "chr15", "chr16", "chr17", "chr18", "chr19", "chr20", "chr21", "chr22"), 
                         id=c("row.name") )
#remove the first part with of data frame, variable = "row.name""


#clean up dm1 (there are a bunch of rows without useful information)
Melted.Hs.male_MLH1 <- Melted.Hs.male_MLH1[(!is.na(Melted.Hs.male_MLH1$value)),]
Melted.Hs.male_MLH1 <- Melted.Hs.male_MLH1[((Melted.Hs.male_MLH1$variable != "row.name")),]
colnames(Melted.Hs.male_MLH1) <- c("row.name", "Chrm.id", "CO")

Melted.Hs.male_axis$Chrm.id <- factor(Melted.Hs.male_axis$Chrm.id, ordered = TRUE, levels=c("chr1","chr2","chr3",  "chr4",  "chr5",  "chr6",  "chr7",  "chr8",  "chr9",  "chr10", "chr11", "chr12", "chr13", "chr14", "chr15", "chr16", "chr17", "chr18", "chr19", "chr20", "chr21", "chr22") )

#Seems like there is an outlier, 
#Melted.Hs.male_axis <- Melted.Hs.male_axis[(Melted.Hs.male_axis$axis.length < 700 #),]

hs.CO.length_plot <- ggplot(Melted.Hs.male_MLH1, aes(y=CO, x=Chrm.id))+geom_jitter(aes( color=row.name, alpha = .2))+ 
  ggtitle("Human male CO Counts")+theme(legend.position="none")
#hs.CO.length_plot
```


## Permutations of Human Data

Heads of the cell-wide summary statistics.

```{r Hs.cell_table, echo=FALSE}
#make table for cell wide measures
Hs.CO_cell_wide <- ddply(.data=Melted.Hs.male_MLH1, 
                            .(row.name),
                            summarize, 
                            nbivs = length(unique(Chrm.id)),
                            n.CO = sum(CO),
                            mean.CO = mean(CO),
                            cV.CO = cv(CO)
)
head(Hs.CO_cell_wide)

Hs.SC_cell_wide <- ddply(.data=Melted.Hs.male_axis, 
                            .(row.name),
                            summarize, 
                            
                            nbivs = length(unique(Chrm.id)),
                            total.SC = sum(axis.length),
                            mean.SC = mean(axis.length),
                            cV.SC = cv(axis.length)#this does within cell cV (dif than cov)
)
head(Hs.SC_cell_wide)

#the mus is rank based on SC, can I write in rank based on Chrm.id
for(cellys in as.character(unique(Melted.Hs.male_axis$row.name))){
  chrm.order = rank(Melted.Hs.male_axis$axis.length[whole.cell.data$row.name == cellys])
  Melted.Hs.male_axis$rank[Melted.Hs.male_axis$row.name == cellys] <- chrm.order  
}


#
two_groups2 <- transform(Melted.Hs.male_axis, category2 = factor(paste(row.name, Chrm.id)))
two_groups2 <- transform(two_groups2, category2 = reorder(category2, rank(desc(axis.length)), decreasing = FALSE))
#use desc for DECENDING order
MiniBiv_line.plot <-  ggplot(two_groups2, aes(category2, axis.length, group=row.name, color=row.name)) +  geom_line(alpha = 0.2) + 
  ggtitle("700 human male chrms ranked by Length")+ labs(x = "")+theme(axis.line=element_blank(),axis.text.x=element_blank(),
        axis.ticks=element_blank()) 

MiniBiv_line.plot


#order by chrm id (they are now an ordered factor)
#it might be kinda hard to subset the melted data, because they aren't organized into cells
#

Melted.Hs.male_axis.mini <- subset(Melted.Hs.male_axis, row.name < 101)

two_groups <- transform(Melted.Hs.male_axis.mini, category2 = factor(paste(row.name, Chrm.id)))
two_groups <- transform(two_groups, category2 = reorder(category2, rank(Chrm.id)))

MiniBiv_line.plot2 <-  ggplot(data=two_groups, aes(category2, axis.length, group=row.name, color=row.name)) +  geom_line(alpha = 0.5) +  ggtitle("700 human male chrms ranked by chrm ID")+ labs(x = "")+theme(axis.line=element_blank(),axis.text.x=element_blank(),
        axis.ticks=element_blank()) 

MiniBiv_line.plot2

#I could check a couple hundred, and remove cells with noticible spikes

```


I added in single cell ranked axis curves. That is 22 axis/chromsomes for a human spermatocyte are ranked smallest to largest and I draw a curve over them. There are 700 cells, which obscure some patterns. A simple discription is that wider/thicker color indicates more variation in the final rank.

I'm trying to think more about the single cell looping factor. -- how would I discribe this, slope of ranked 
Sometimes the chrm id doesn't fit rank expectations.  (looking at the mini.biv plots, )

I ran two types of permutations for the CO count per cell data. 'sim no rank' is a dataset where chromosome CO counts were drawn from the entire pool of chromosome observations. 'Sim w.rank' is a randomized pool, but each cell is made of random draws from one of each of the chromosome bins.

I didn't test the axis length trait yet.  (See below for axis traits)



```{r Hs.Perm_noRank, echo=FALSE}

Melted.Hs.male_MLH1$chrm.num <- (Melted.Hs.male_MLH1$Chrm.id)
levels(Melted.Hs.male_MLH1$chrm.num) <- 1:23

Melted.Hs.male_MLH1$chrm.num <- as.character(Melted.Hs.male_MLH1$chrm.num)
Melted.Hs.male_MLH1$chrm.num <- as.numeric(Melted.Hs.male_MLH1$chrm.num)
#chrm.num is now 1:23

#LIST of DF, no rank (include all), samples all 19 bivs at a time
Hs_male.BIG.DF.LIST_no.rank <- replicate(755,
                  list(bind_rows(list( 
          #can't make do logic on factors
          Melted.Hs.male_MLH1[ sample( which( Melted.Hs.male_MLH1$chrm.num < 24), 22),]
) ) ) )
#now have randomized DF of 1000 cells
```


```{r Hs.Perm_wRank, echo=FALSE}
#rank (sample all of the ranks then stich them together)
Hs.CO_BIG.LIST_w.rank <- replicate(755,
  list(bind_rows(list( 

  Melted.Hs.male_MLH1[ sample( which(Melted.Hs.male_MLH1$chrm.num==2), 1, replace = FALSE ),],
  Melted.Hs.male_MLH1[ sample( which(Melted.Hs.male_MLH1$chrm.num==3), 1, replace = FALSE ),],
  Melted.Hs.male_MLH1[ sample( which(Melted.Hs.male_MLH1$chrm.num==4), 1, replace = FALSE ),],
  Melted.Hs.male_MLH1[ sample( which(Melted.Hs.male_MLH1$chrm.num==5), 1, replace = FALSE ),],
   Melted.Hs.male_MLH1[ sample( which(Melted.Hs.male_MLH1$chrm.num==6), 1, replace = FALSE ),],
  Melted.Hs.male_MLH1[ sample( which(Melted.Hs.male_MLH1$chrm.num==7), 1, replace = FALSE ),],
  Melted.Hs.male_MLH1[ sample( which(Melted.Hs.male_MLH1$chrm.num==8), 1, replace = FALSE ),],
  Melted.Hs.male_MLH1[ sample( which(Melted.Hs.male_MLH1$chrm.num==9), 1, replace = FALSE ),],
  Melted.Hs.male_MLH1[ sample( which(Melted.Hs.male_MLH1$chrm.num==10), 1, replace = FALSE ),],
  
   Melted.Hs.male_MLH1[ sample( which(Melted.Hs.male_MLH1$chrm.num==11), 1, replace = FALSE ),],
  Melted.Hs.male_MLH1[ sample( which(Melted.Hs.male_MLH1$chrm.num==12), 1, replace = FALSE ),],
  Melted.Hs.male_MLH1[ sample( which(Melted.Hs.male_MLH1$chrm.num==13), 1, replace = FALSE ),],
  Melted.Hs.male_MLH1[ sample( which(Melted.Hs.male_MLH1$chrm.num==14), 1, replace = FALSE ),],
  Melted.Hs.male_MLH1[ sample( which(Melted.Hs.male_MLH1$chrm.num==15), 1, replace = FALSE ),],
  Melted.Hs.male_MLH1[ sample( which(Melted.Hs.male_MLH1$chrm.num==16), 1, replace = FALSE ),],
  Melted.Hs.male_MLH1[ sample( which(Melted.Hs.male_MLH1$chrm.num==17), 1, replace = FALSE ),],
  Melted.Hs.male_MLH1[ sample( which(Melted.Hs.male_MLH1$chrm.num==18), 1, replace = FALSE ),],
  Melted.Hs.male_MLH1[ sample( which(Melted.Hs.male_MLH1$chrm.num==19), 1, replace = FALSE ),],
    Melted.Hs.male_MLH1[ sample( which(Melted.Hs.male_MLH1$chrm.num==20), 1, replace = FALSE ),],
  Melted.Hs.male_MLH1[ sample( which(Melted.Hs.male_MLH1$chrm.num==21), 1, replace = FALSE ),],
    Melted.Hs.male_MLH1[ sample( which(Melted.Hs.male_MLH1$chrm.num==22), 1, replace = FALSE ),],
      Melted.Hs.male_MLH1[ sample( which(Melted.Hs.male_MLH1$chrm.num==23), 1, replace = FALSE ),]
))
)) #list of DFs which are 'cells' with observations drawn from pooled chrm bins
```

```{r sum.stat.display, echo=FALSE}
#after making big randomize / permuted data sets, CALCULATE the metrics / sum.stat
#Hs.CO_BIG.LIST_w.rank
#Hs_male.BIG.DF.LIST_no.rank


#Calq cV for the rank perm
#1. make empty DF
Hs.CO_cv_rank <- data.frame(  cV.CO = rep(0, length(Hs.CO_BIG.LIST_w.rank) ) )

for(j in 1:length(Hs.CO_BIG.LIST_w.rank)){  #inside loop, move thru the LISTs of DFs
  #print(j)
  #fill in the cells of given index
  Hs.CO_cv_rank$cV.CO[j] <-cv(  Hs.CO_BIG.LIST_w.rank[[j]]$CO ) #but j should be row, row should be a cell
  #add CO per nuc
  Hs.CO_cv_rank$co.per.nuc[j] <- sum(Hs.CO_BIG.LIST_w.rank[[j]]$CO)
  }

#Calq cV for no rank
Hs.CO_cv_no.rank <- data.frame(  cV.CO = rep(0, length(Hs_male.BIG.DF.LIST_no.rank) ) ) #first initialize the DF results will go in outside of loop
for(i in 1:length(Hs_male.BIG.DF.LIST_no.rank)){  #inside loop, move thru the LISTs of DFs
  #print(i)
  #fill in the cells of given index
  Hs.CO_cv_no.rank$cV.CO[i] <-cv(  Hs_male.BIG.DF.LIST_no.rank[[i]]$CO )
  Hs.CO_cv_no.rank$co.per.nuc[i] <- sum(Hs_male.BIG.DF.LIST_no.rank[[i]]$CO) #these are the total sum, not divided out by nuc!
  }

#merge simulated and real values into 1DF
Hs.CO_cv_rank$type <- "sim w.rank"
colnames(Hs.CO_cv_rank) <- c("cV","COs","type" )

Hs.CO_cv_no.rank$type <- "sim no rank"
colnames(Hs.CO_cv_no.rank) <- c("cV", "COs","type")

#then add the real values   Hs.CO_cell_wide
Hs_real.cv.co <- data.frame(cV = Hs.CO_cell_wide$cV.CO, Hs.CO_cell_wide$n.CO)
Hs_real.cv.co$type <- "real"
colnames(Hs_real.cv.co) <- c("cV","COs", "type")

#merge
Hs.CO_cVs.DF <- rbind(Hs.CO_cv_rank, Hs.CO_cv_no.rank, Hs_real.cv.co)

# need to melt the DFs before ploting?
#ploting --- plot with more sims
#HS.plot <- ggplot(Hs.CO_cVs.DF, aes(y = cV, x=type) )+ geom_jitter()+ ggtitle("Cell-wide cv for CO, Human male")
#HS.plot
```


```{r HS.plots, echo=FALSE}

HS.scatter.plot <- ggplot(Hs.CO_cVs.DF, aes(y = COs, x=type) )+ geom_jitter()+ ggtitle("COs per cell, Human male")

hist <- ggplot(Hs.CO_cVs.DF, aes(x = COs)) + geom_histogram(aes(fill=type), binwidth = 2 )


HS.density.plot <- ggplot(Hs.CO_cVs.DF, aes(x = COs, fill=type) )+geom_density(alpha=.6) + ggtitle("CO per cell, Human male")+xlim(c(0,100))
HS.density.plot
```

Qualitatively these results look the same as in the Wang et al 2019 paper. I haven't confirmed the calculations with a variability index. To calculate the 'variability index', the authors take the percentage of cells (or integrated curve area) which differ between the empirical and simulated distributions. I still need to do some work to make sure I can calculate the differences in distributions.

The rank distinction is to test if sampling within pools of specific chromosomes makes a difference. The smaller/tighter distribution between CO count per nuc with the ranked and non-ranked distributions indicate there is a small chromosome specific effect.


# Mus whole Cell Data Set


```{r setup.whole.cell.data, echo=FALSE, warning=FALSE}

#add sex since there is a difference in sample size
whole.cell.data <- add_mouse(whole.cell.data)
whole.cell.data <- add_sex(whole.cell.data)
whole.cell.data <- add_strain(whole.cell.data)
whole.cell.data <- add_category(whole.cell.data)

whole.cell.data <- whole.cell.data[!(is.na(whole.cell.data$fileName) | whole.cell.data$fileName==""), ]
#this doesn't remove all of the data that are missing values

whole.cell.data$Obj.ID <- paste(whole.cell.data$fileName, whole.cell.data$boxNumber, sep = "_")

whole.cell.data.XY <- whole.cell.data
whole.cell.data <- whole.cell.data[(whole.cell.data$hand.foci.count!="XY"), ]

whole.cell.data$hand.foci.count <- as.numeric(as.character(whole.cell.data$hand.foci.count))
whole.cell.data$SC.length <- as.numeric(as.character(whole.cell.data$SC.length))

whole.cell.data$F1 <- as.numeric(as.character(whole.cell.data$F1))
whole.cell.data$F2 <- as.numeric(as.character(whole.cell.data$F2))
whole.cell.data$F3 <- as.numeric(as.character(whole.cell.data$F3))


whole.cell.data$Foci1 <- whole.cell.data$F1
whole.cell.data$Foci2 <- whole.cell.data$F2
whole.cell.data$Foci3 <- whole.cell.data$F3

#add IFDs and normalized positions 
whole.cell.data$Foci1.PER <- whole.cell.data$Foci1 / whole.cell.data$SC.length
whole.cell.data$Foci2.PER <- whole.cell.data$Foci2 / whole.cell.data$SC.length
whole.cell.data$Foci3.PER <- whole.cell.data$Foci3 / whole.cell.data$SC.length

whole.cell.data <- add_IFD(whole.cell.data)
#whole.cell.data <-  add_IFD.2(whole.cell.data)



whole.cell.data <- whole.cell.data[!(is.na(whole.cell.data$SC.length) | whole.cell.data$SC.length==""), ]


#ADD THE RANK -- this stoped working for a bit, 
#fixed it with rank
for(musy in as.character(unique(whole.cell.data$fileName))){
  #print(musy)
  #order the chrm lengths -- this is order
  chrm.order = rank(whole.cell.data$SC.length[whole.cell.data$fileName == musy])
  whole.cell.data$rank[whole.cell.data$fileName == musy] <- chrm.order   #this is just a string of numbers--
  
}

```


```{r Mus.physcial.genome, echo=FALSE}
#distribution of genome sizes from reference Mus genome
#haploid genome size
refMus.geome_Mb_male <- c(195,182,160,152,150,145,129,125,131,122,120,120,125,104,91,95,91,61)# 1109.412

refMus.geome_Mb_XX <- c(195,182,160,152,150,145,129,125,131,122,120,120,125,104,91,95,91,61, 171)

#note, this ommits telomeres and centromeres!
#read the 
#on average 8Mb worth of centromeres and telomeres are added to each chrm
#i will try to find estimates of variation across indiviual chromosomes

```

Show a plot of the estimates chrm sizes. These values from MGI page omit centromere and telomere estimates. Read up on the T2T project lit to see if I can find better estimates of physical chormosome sizes.


Do I need most accurate estimate of Mb size variance? would I expect -- similar variance among cells? If i ran jack-knifing or sub-sampling permutations of the within cell covariance calculations -- if the covariation eatimate remained about the same, I would be more convinced that the 'packing' ratio is mostly uniform WITHIN cells.
Null/ comparison value might be, randomize cell.id for all bivalent observations.
(maybe I should first try this in human data? (minus the wacky looking cells / bad chrm id))

This might be the best thing to do to account for different physical sizes across other strains (non reference genome)


I have a data set of hand measured whole cells, in excel sheet Whole_cell_measures.xlsx with has 840 bivalent measures. The table below shows the number of bivalent observations by categories.

The whole cell comparisons (from empirical and randomized distributions):
- CO counts per cell
- Total SC per cell (calculated by single bivalents)
- CO position (cell wide rbar, mean telomere bias)

The CO position metrics might change.


```{r whole.cell.table, echo=FALSE}
table(whole.cell.data$category)
#table(cell.table$category)

```

```{r make.nother.table, echo=FALSE}

whole.cell.biv.count_table <-  ddply(.data=whole.cell.data,
                 .(fileName),
                 summarize,
                 nbiv = length(SC.length),
                  #THIS IS WHERE THE error is thrown
                 nCO0 =  sum(which(hand.foci.count == 0), na.rm=TRUE)
                 #SUM not meaningful for factors
)               

                 #  nCO0 =  sum(hand.foci.count == 0, na.rm=TRUE), 
            #      nCO1 =  sum(hand.foci.count == 1, na.rm=TRUE),# 
             #     nCO2 = sum(hand.foci.count == 2, na.rm=TRUE),
            #      nCO3 = sum(hand.foci.count == 3, na.rm=TRUE),
                 
          #       totCO = sum(hand.foci.count),
          #       total.SC = sum(SC.length),
          #       mean_co = mean(hand.foci.count, na.rm = TRUE),
          #       mean_sc = mean(SC.length),
              #     var_co = var(hand.foci.count),
              #     var_sc = var(SC.length),
              #   cv_co.count = cv(hand.foci.count),
             #    cv_SC.length = cv(SC.length)
#)


```



```{r cell.level.tables, echo=FALSE}
whole.cell.data <- whole.cell.data[(whole.cell.data$hand.foci.count!="XY"), ]

male.whole.cell <- whole.cell.data[whole.cell.data$sex == "male", ]#359

female.whole.cell <- whole.cell.data[whole.cell.data$sex == "female", ]#456


biv.count_table <-  ddply(.data=whole.cell.data,
                 .(fileName),
                 summarize,
                 nbiv = length(SC.length)
)#all have 20 or 19 (after removing XY)

#real data
male.biv.count_table <-  ddply(.data=male.whole.cell,
                 .(fileName),
                 summarize,
                 nbiv = length(SC.length),
                  nCO0 =  sum(hand.foci.count == 0, na.rm=TRUE), 
                  nCO1 =  sum(hand.foci.count == 1, na.rm=TRUE), 
                  nCO2 = sum(hand.foci.count == 2, na.rm=TRUE),
                  nCO3 = sum(hand.foci.count == 3, na.rm=TRUE),
                 
                 totCO = sum(hand.foci.count),
                 total.SC = sum(SC.length),
                 mean_co = mean(hand.foci.count, na.rm = TRUE),
                 mean_sc = mean(SC.length),
                   var_co = var(hand.foci.count),
                   var_sc = var(SC.length),
                 cv_co.count = cv(hand.foci.count),
                 cv_SC.length = cv(SC.length)
)
#exclude last one
male.biv.count_table <- male.biv.count_table[!(is.na(male.biv.count_table$fileName) | male.biv.count_table$fileName==""), ]


male.biv.count_table$ratio.now <- var(refMus.geome_Mb_male) / male.biv.count_table$var_sc
male.biv.count_table$ratio.invert <-  male.biv.count_table$var_sc / var(refMus.geome_Mb_male)
#have to think of which is right

female.biv.count_table <-  ddply(.data=female.whole.cell,
                 .(fileName),
                 summarize,
                 nbiv = length(SC.length),
                 nCO0 =  sum(hand.foci.count == 0, na.rm=TRUE), 
                nCO1 =  sum(hand.foci.count == 1, na.rm=TRUE), 
                 nCO2 = sum(hand.foci.count == 2, na.rm=TRUE),
                 nCO3 = sum(hand.foci.count == 3, na.rm=TRUE),
                 
                 totCO = sum(hand.foci.count, na.rm = TRUE),
                  total.SC = sum(SC.length, na.rm = TRUE),
                 mean_co = mean(hand.foci.count, na.rm = TRUE),
                 mean_sc = mean(SC.length, na.rm = TRUE),
                   var_co = var(hand.foci.count),
                   var_sc = var(SC.length),
                 cv_co.count = cv(hand.foci.count),
                 cv_SC.length = cv(SC.length)
)
#exclude last nas
female.biv.count_table <- female.biv.count_table[!(is.na(female.biv.count_table$fileName) | female.biv.count_table$fileName==""), ]

female.biv.count_table$ratio.now <- var(refMus.geome_Mb_XX) / female.biv.count_table$var_sc


female.biv.count_table$ratio.invert <-  female.biv.count_table$var_sc / var(refMus.geome_Mb_XX)

#plot these variances, do them for male and female


```


```{r var.ratios.plot, echo=FALSE}

#var(refMus.geome_Mb_XX) #1146.608
#var(refMus.geome_Mb_male) #1109.412

#female.biv.count_table, table of 18 cells with their summary stats

female.cell.var.ratios <- ggplot(female.biv.count_table, aes(ratio.now, fileName))+geom_point()
female.cell.var.ratios

male.cell.var.ratios <- ggplot(male.biv.count_table, aes(ratio.now, fileName))+geom_point()
male.cell.var.ratios

female.biv.count_table$sex <- "female"
male.biv.count_table$sex <- "male"

biv.ratio.table <- rbind(female.biv.count_table, male.biv.count_table)

biv.ratio.table <- add_mouse(biv.ratio.table)
biv.ratio.table <- add_strain(biv.ratio.table)

all.ratios <- ggplot(biv.ratio.table, aes(y=ratio.now, x=strain, color=strain))+geom_jitter()+facet_wrap(~sex)+ggtitle("")+ylab(" var(chrm size Mb) : var(SC lengths)")+theme_bw()

```


A question which is fundamental to these Chap3 analyses:

 - Is chrom axis compaction an accurate reflection on the actual physical chrm size? (is ranked SC length a decent predictor for chromosome identity?)

Trying to address this by calculating the ratio between the within cell variance of SC lengths and the variance of chromsomes, ohysical sizes (mb) (haploid sizes from ref genome)


The variance across SC is always smaller than variance across chrm sizes. could be due to different resolution of microscope (SC).

what is a better name for this ratio? Chrm size variation (mB), and bivalent length variation (uM)

true compaction ratio, compaction fedelity ratio, ... it's a ratio of variances, so those might be not be the best choices


there is a negative relatioship with total SC and this ratio

- is total SC a good metric for comparing with this?

-is it strange that males have a clear min/higher min?

-do the strains cluster with their ratios? ... still unbalanced data

Male cell ratios are mostly 


above are ratios for indiviual cells, ratio of the variance of the physical chrm lengths (predicted, no centromere or telomere) to the variance of bivalents in SC.


Calculated the ratio of genome size variance (haploid chrm variance), (I think the right denominator is SC length variance)
most all are above 1 (for both female and male) -- indicates the packing ratio / packing process doesn't maintain (our guess about genome size of chromosomes)


I calculate within cell ranked SC length to use rank as a proxy for chromosome ID for bivalents. 

Below are plots of the SC distributions across the rank

```{r play.plots, echo=FALSE, warning=FALSE}
#female.whole.cell
#male.whole.cell
female.whole.cell <- female.whole.cell[!(is.na(female.whole.cell$SC.length) | female.whole.cell$SC.length==""), ]

cow.hugger <- ggplot(female.whole.cell, aes(x=rank, y=SC.length, color=mouse) ) +geom_jitter()

rank.length.boxplot <- ggplot(data=female.whole.cell) + geom_boxplot( aes(x=as.factor(rank), y=SC.length, fill=rank) )+geom_jitter(aes(x=as.factor(rank), y=SC.length) )+ggtitle("blaah")



rank.length.boxplot.xx <- ggplot(data=female.whole.cell, aes(x=as.factor(rank), y=SC.length) ) + geom_boxplot()+ geom_jitter(aes( color=fileName))+
  ggtitle("Female SC Length Dist by ranks")+theme(legend.position="none")

rank.length.boxplot.xy <- ggplot(data=male.whole.cell, aes(x=as.factor(rank), y=as.numeric(SC.length) )) + geom_boxplot()+ geom_jitter(aes( color=fileName)) +ggtitle("Male SC Length Dist by ranks")+theme(legend.position="none")


rank.length.boxplot.xx
rank.length.boxplot.xy

```


The plots above look much different than when I first made them. The SC values might not be right.


# Mus Permutation Setup

I will make the permuted data sets once and display the summary stats (and compare the empirical to random distribution).

I will us the same rank and non-ranked version of permutations as I did for the human data. Since I don't have chromosome IDs, I will use the within cell SC length ranks as a proxy for chromosome identity (rank).


## CO count, male

Theses code chunks make a data set of 24 nuclei with 19 random chromosome draws each.

```{r list.of.DF, echo=FALSE, warning=FALSE}
#rank (sample all of the ranks then stich them together)
#replication should match the num
BIG.LIST_w.rank <- replicate(24,
  list(bind_rows(list( 
  male.whole.cell[ sample( which(male.whole.cell$rank==1), 1, replace = FALSE ),],
  male.whole.cell[ sample( which(male.whole.cell$rank==2), 1, replace = FALSE ),],
  male.whole.cell[ sample( which(male.whole.cell$rank==3), 1, replace = FALSE ),],
  male.whole.cell[ sample( which(male.whole.cell$rank==4), 1, replace = FALSE ),],
  male.whole.cell[ sample( which(male.whole.cell$rank==5), 1, replace = FALSE ),],
   male.whole.cell[ sample( which(male.whole.cell$rank==6), 1, replace = FALSE ),],
  male.whole.cell[ sample( which(male.whole.cell$rank==7), 1, replace = FALSE ),],
  male.whole.cell[ sample( which(male.whole.cell$rank==8), 1, replace = FALSE ),],
  male.whole.cell[ sample( which(male.whole.cell$rank==9), 1, replace = FALSE ),],
  male.whole.cell[ sample( which(male.whole.cell$rank==10), 1, replace = FALSE ),],
  
   male.whole.cell[ sample( which(male.whole.cell$rank==11), 1, replace = FALSE ),],
  male.whole.cell[ sample( which(male.whole.cell$rank==12), 1, replace = FALSE ),],
  male.whole.cell[ sample( which(male.whole.cell$rank==13), 1, replace = FALSE ),],
  male.whole.cell[ sample( which(male.whole.cell$rank==14), 1, replace = FALSE ),],
  male.whole.cell[ sample( which(male.whole.cell$rank==15), 1, replace = FALSE ),],
  male.whole.cell[ sample( which(male.whole.cell$rank==16), 1, replace = FALSE ),],
  male.whole.cell[ sample( which(male.whole.cell$rank==17), 1, replace = FALSE ),],
  male.whole.cell[ sample( which(male.whole.cell$rank==18), 1, replace = FALSE ),],
  male.whole.cell[ sample( which(male.whole.cell$rank==19), 1, replace = FALSE ),]
))))
#this is replicating single cell (NOT a SAMPLE of 24)


#LIST of DF, no rank (include all), samples all 19 bivs at a time
#makes a list of 10 -- [[]]
BIG.DF.LIST_no.rank <- replicate(24,
                  list(bind_rows(list( 
          male.whole.cell[ sample( which( male.whole.cell$rank < 20), 19, replace = FALSE ),]
) ) ) )
```


```{r sum.stat, echo=FALSE, warning=FALSE}
#dealing with lists of DFs, 
#2. #Loop through the list of DFs and do the ... make the cell level cVs calculations
#i is this index of the dataframes in the list?

#Calq cV for the rank perm
cv.val.DF_rank <- data.frame(  cV = rep(0, length(BIG.LIST_w.rank) ) ) #first initialize the DF results will go in outside of loop
for(j in 1:length(BIG.LIST_w.rank)){  #inside loop, move thru the LISTs of DFs
 # print(j)
  #fill in the cells of given index
  cv.val.DF_rank$cV[j] <-cv(  BIG.LIST_w.rank[[j]]$hand.foci.count )
    cv.val.DF_rank$CO[j] <-sum(  BIG.LIST_w.rank[[j]]$hand.foci.count )
  
    }

#Calq cV for no rank
cv.val.DF_no.rank <- data.frame(  cV_CO = rep(0, length(BIG.DF.LIST_no.rank) ) ) #first initialize the DF results will go in outside of loop
for(i in 1:length(BIG.DF.LIST_no.rank)){  #inside loop, move thru the LISTs of DFs
  #print(i)
  #fill in the cells of given index
  cv.val.DF_no.rank$cV_CO[i] <-cv(  BIG.DF.LIST_no.rank[[i]]$hand.foci.count )
   cv.val.DF_no.rank$CO[i] <- sum(  BIG.DF.LIST_no.rank[[i]]$hand.foci.count )
  }
#extract the 
#next step make cell-level calqs of cV -- for plotting

#merge + plots of the cvs
#10 and 10 rows from the permuted
cv.val.DF_rank$type <- "sim w.rank"
colnames(cv.val.DF_rank) <- c("cV", "CO", "type" )

cv.val.DF_no.rank$type <- "sim no rank"
colnames(cv.val.DF_no.rank) <- c("cV", "CO", "type")

#then add the real values
real.vals.cv.co <- data.frame(male.biv.count_table$cv_co.count, male.biv.count_table$totCO )
real.vals.cv.co$type <- "real"
colnames(real.vals.cv.co) <- c("cV","CO", "type")

#merge
cVs_permutations.DF <- rbind(cv.val.DF_rank, cv.val.DF_no.rank, real.vals.cv.co)

#  geom_histogram(bins = 50)+facet_wrap(.~Test.type, scales = "free") 
#biggie <- ggplot(Melted.pval.DF, aes(pval) )+geom_histogram(bins = 50)+facet_wrap(.~Test.type, scales = "free") + ggtitle("pvalues for 1000 replicated t.tests")
```


```{r perm.plots, echo=FALSE, warning=FALSE}
#plots for permutations

# need to melt the DFs before ploting?
#ploting --- plot with more sims
oo.plot <- ggplot(cVs_permutations.DF, aes(y = cV, x=type) )+ geom_jitter()+ ggtitle("cv for cell co count, 1000 simulated")

 
Mus_hist <- ggplot(cVs_permutations.DF, aes(x = CO)) + geom_histogram(aes(fill=type), binwidth = 2 )+ggtitle("COs per cell, Mus male")


HS.density.plot <- ggplot(cVs_permutations.DF, aes(x = CO, fill=type) )+geom_density(alpha=.6) + ggtitle("CO per cell, Mus male")+xlim(c(0,100))
HS.density.plot

```

Above plot shows over dispersion of CO counts per cell for my Mus male data set.
The above plot the real data might have more variance because it's a combination of strains


## CO count, female

For mus, data frames that sample based on SC.length / rank, can be used for SC length and CO count metrics. Not CO position

both SC and CO count randomized data 

These code chunks make a randomized data set of 18 nuclei with 20 random chromosome draws each.

```{r rand.DF_CO.count.female, echo=FALSE, warning=FALSE}

#make subsampled piece of DF here -- these are taking the whole DF
#I will just take single values
#Curated_BivData[ sample( which(Curated_BivData$category=="WSB female"), Biv.sample.Number ), ]
#male.whole.cell
#rand.rank.co <- sample(male.whole.cell$hand.foci.count[male.whole.cell$rank == col.num-1], 1, replace = FALSE)

#rank (sample all of the ranks then stich them together)
BIG.LIST_w.rank_female <- replicate(24,
  list(bind_rows(list( 
  female.whole.cell[ sample( which(female.whole.cell$rank==1), 1, replace = FALSE ),],
  female.whole.cell[ sample( which(female.whole.cell$rank==2), 1, replace = FALSE ),],
  female.whole.cell[ sample( which(female.whole.cell$rank==3), 1, replace = FALSE ),],
  female.whole.cell[ sample( which(female.whole.cell$rank==4), 1, replace = FALSE ),],
  female.whole.cell[ sample( which(female.whole.cell$rank==5), 1, replace = FALSE ),],
   female.whole.cell[ sample( which(female.whole.cell$rank==6), 1, replace = FALSE ),],
  female.whole.cell[ sample( which(female.whole.cell$rank==7), 1, replace = FALSE ),],
  female.whole.cell[ sample( which(female.whole.cell$rank==8), 1, replace = FALSE ),],
  female.whole.cell[ sample( which(female.whole.cell$rank==9), 1, replace = FALSE ),],
  female.whole.cell[ sample( which(female.whole.cell$rank==10), 1, replace = FALSE ),],
  
   female.whole.cell[ sample( which(female.whole.cell$rank==11), 1, replace = FALSE ),],
  female.whole.cell[ sample( which(female.whole.cell$rank==12), 1, replace = FALSE ),],
  female.whole.cell[ sample( which(female.whole.cell$rank==13), 1, replace = FALSE ),],
  female.whole.cell[ sample( which(female.whole.cell$rank==14), 1, replace = FALSE ),],
  female.whole.cell[ sample( which(female.whole.cell$rank==15), 1, replace = FALSE ),],
  female.whole.cell[ sample( which(female.whole.cell$rank==16), 1, replace = FALSE ),],
  female.whole.cell[ sample( which(female.whole.cell$rank==17), 1, replace = FALSE ),],
  female.whole.cell[ sample( which(female.whole.cell$rank==18), 1, replace = FALSE ),],
  female.whole.cell[ sample( which(female.whole.cell$rank==19), 1, replace = FALSE ),],
  female.whole.cell[ sample( which(female.whole.cell$rank==20), 1, replace = FALSE ),]
  ))))


#LIST of DF, no rank (include all), samples all 19 bivs at a time
BIG.DF.LIST_no.rank_female <- replicate(24,
                  list(bind_rows(list( 
          female.whole.cell[ sample( which( female.whole.cell$rank < 20), 20, replace = FALSE ),]
) ) ) )

```


```{r sum.stat_cv.CO, echo=FALSE, warning=FALSE}
#CALUCULATING SUMMARY STAT from the permuted DFs
#dealing with lists of DFs, 
#2. #Loop through the list of DFs and do the ... make the cell level cVs calculations
#i is this index of the dataframes in the list?

#Calq cV for the rank perm
cv.val.DF_rank.female <- data.frame(  cV = rep(0, length(BIG.LIST_w.rank_female) ) ) #first initialize the DF results will go in outside of loop
for(j in 1:length(BIG.LIST_w.rank_female)){  #inside loop, move thru the LISTs of DFs
 # print(j)
  #fill in the cells of given index
  cv.val.DF_rank.female$cV[j] <-cv(  BIG.LIST_w.rank_female[[j]]$hand.foci.count ) #for each
  cv.val.DF_rank.female$CO[j] <-sum(  BIG.LIST_w.rank_female[[j]]$hand.foci.count )
  }


#Calq cV for no rank
cv.val.DF_no.rank.female <- data.frame(  cV = rep(0, length(BIG.DF.LIST_no.rank_female) ) ) #first initialize the DF results will go in outside of loop
for(i in 1:length(BIG.DF.LIST_no.rank_female)){  #inside loop, move thru the LISTs of DFs
  #print(i)
  #fill in the cells of given index
  cv.val.DF_no.rank.female$cV[i] <-cv(  BIG.DF.LIST_no.rank_female[[i]]$hand.foci.count )
  cv.val.DF_no.rank.female$CO[i] <-sum(  BIG.DF.LIST_no.rank_female[[i]]$hand.foci.count )
}

#merge + plots of the cvs
#10 and 10 rows from the permuted
cv.val.DF_rank.female$type <- "sim w.rank"
colnames(cv.val.DF_rank) <- c("cV","CO","type" )

cv.val.DF_no.rank.female$type <- "sim no rank"
colnames(cv.val.DF_no.rank.female) <- c("cV","CO", "type")

#then add the real values
real.vals.cv.co_female <- data.frame(cv = female.biv.count_table$cv_co.count, CO = female.biv.count_table$totCO)
real.vals.cv.co_female$type <- "real"
colnames(real.vals.cv.co_female) <- c("cV","CO", "type")

#merge
cVs_permutations.DF_female <- rbind(cv.val.DF_rank.female, cv.val.DF_no.rank.female, real.vals.cv.co_female)


# need to melt the DFs before ploting?
#ploting --- plot with more sims
Femaleplot_cV <- ggplot(cVs_permutations.DF_female, aes(y = cV, x=type) )+ geom_jitter()+ ggtitle("cv for cell co count female, 1000 simulated")
  

Mus_hist_F <- ggplot(cVs_permutations.DF_female, aes(x = CO)) + geom_histogram(aes(fill=type), binwidth = 2 )+ggtitle("COs per cell, Mus female")


Mus.density.plot_F <- ggplot(cVs_permutations.DF_female, aes(x = CO, fill=type) )+geom_density(alpha=.6) + ggtitle("CO per cell, Mus female")+xlim(c(0,50))
Mus.density.plot_F

#  geom_histogram(bins = 50)+facet_wrap(.~Test.type, scales = "free") 

#biggie <- ggplot(Melted.pval.DF, aes(pval) )+geom_histogram(bins = 50)+facet_wrap(.~Test.type, scales = "free") + ggtitle("pvalues for 1000 replicated t.tests")

cVs_permutations.DF$sex <- "male"
cVs_permutations.DF_female$sex <- "female"

all.cv <- rbind(cVs_permutations.DF, cVs_permutations.DF_female)
cV_plot <- ggplot(all.cv, aes(y = cV, x=type) )+ geom_jitter()+ ggtitle("cv for cell co count, 1000 simulated")+facet_wrap(~sex)

```

Density plot above also shows that the female CO count data is over dispersed compered to a randomized distribution.


# SC length, bivalent level

Comparing cell wide statistics for SC lengths across the real and randomized data sets.


```{r SC_Sum.Stats.male, echo=FALSE, warning=FALSE}
# calq the sum stats
SC_Mus.male_w.rank <- data.frame(  SC.cv = rep(0, length(BIG.LIST_w.rank) ) ) #first initialize the DF results will go in outside of loop
for(j in 1:length(BIG.LIST_w.rank)){  #inside loop, move thru the LISTs of DFs
 # print(j)
  #fill in the cells of given index
  SC_Mus.male_w.rank$SC.cv[j] <-cv(  BIG.LIST_w.rank[[j]]$SC.length ) #for each
  SC_Mus.male_w.rank$total_SC[j] <-sum(  BIG.LIST_w.rank[[j]]$SC.length )
  SC_Mus.male_w.rank$mean_SC[j] <-mean(  BIG.LIST_w.rank[[j]]$SC.length )
  }

#Calq cV for no rank
SC_Mus.male_no.rank <- data.frame(  cV = rep(0, length(BIG.DF.LIST_no.rank) ) ) #first initialize the DF results will go in outside of loop
for(i in 1:length(BIG.DF.LIST_no.rank)){  #inside loop, move thru the LISTs of DFs
  #print(i)
  #fill in the cells of given index
  SC_Mus.male_no.rank$cV[i] <-cv(  BIG.DF.LIST_no.rank[[i]]$SC.length )
  SC_Mus.male_no.rank$total_SC[i] <-sum(  BIG.DF.LIST_no.rank[[i]]$SC.length )
  SC_Mus.male_no.rank$mean_SC[i] <-mean(  BIG.DF.LIST_no.rank[[i]]$SC.length )
}


#10 and 10 rows from the permuted
SC_Mus.male_w.rank$type <- "sim w.rank"
colnames(SC_Mus.male_w.rank) <- c("SC.cV", "tot.SC", "mean.SC", "type" )

SC_Mus.male_no.rank$type <- "sim_no.rank"
colnames(SC_Mus.male_no.rank) <- c("SC.cV", "tot.SC", "mean.SC", "type" )

real_SC.Mus <- data.frame(male.biv.count_table$var_sc,  male.biv.count_table$total.SC, male.biv.count_table$mean_sc )
real_SC.Mus$type <- "real"

colnames(real_SC.Mus) <- c("SC.cV", "tot.SC", "mean.SC", "type")
#merge
SC_Mus_male <- rbind(SC_Mus.male_w.rank, SC_Mus.male_no.rank,real_SC.Mus)

```

```{r SC.plots_Mus.male, echo=FALSE, warning=FALSE}
Mus_SC_hist <- ggplot(SC_Mus_male, aes(x = tot.SC)) + geom_histogram(aes(fill=type), binwidth = 50 )+ggtitle("total SC per cell, Mus male")

Mus_SC_density <- ggplot(SC_Mus_male, aes(x = tot.SC, fill=type) )+geom_density(alpha=.6) + ggtitle("Total SC per cell, Mus male")+xlim(c(800,2000))
Mus_SC_density

#plot the forms
#plot within cell variance
#whole.cell.var_SC.plot  <- ggplot(sc.var.for.plot, aes(y=var, x=type))+geom_jitter()+ggtitle("within cell sc variance")
```

```{r SC_sum.stats.female, echo=FALSE}

# calq the sum stats
SC_Mus.female_w.rank <- data.frame(  SC.cv = rep(0, length(BIG.LIST_w.rank_female) ) ) #first initialize the DF results will go in outside of loop
for(j in 1:length(BIG.LIST_w.rank_female)){  #inside loop, move thru the LISTs of DFs
 # print(j)
  #fill in the cells of given index
  SC_Mus.female_w.rank$SC.cv[j] <-cv(  BIG.LIST_w.rank_female[[j]]$SC.length ) #for each
  SC_Mus.female_w.rank$total_SC[j] <-sum(  BIG.LIST_w.rank_female[[j]]$SC.length )
  SC_Mus.female_w.rank$mean_SC[j] <-mean(  BIG.LIST_w.rank_female[[j]]$SC.length )
  }

#Calq cV for no rank,   BIG.DF.LIST_no.rank_female
SC_Mus.female_no.rank <- data.frame(  cV = rep(0, length(BIG.DF.LIST_no.rank_female) ) ) #first initialize the DF results will go in outside of loop
for(i in 1:length(BIG.DF.LIST_no.rank_female)){  #inside loop, move thru the LISTs of DFs
  #print(i)
  #fill in the cells of given index
  SC_Mus.female_no.rank$cV[i] <-cv(  BIG.DF.LIST_no.rank_female[[i]]$SC.length )
  SC_Mus.female_no.rank$total_SC[i] <-sum(  BIG.DF.LIST_no.rank_female[[i]]$SC.length, na.rm = TRUE )
  SC_Mus.female_no.rank$mean_SC[i] <-mean(  BIG.DF.LIST_no.rank_female[[i]]$SC.length, na.rm=TRUE )
}


#10 and 10 rows from the permuted
SC_Mus.female_w.rank$type <- "sim w.rank"
colnames(SC_Mus.female_w.rank) <- c("SC.cV", "tot.SC", "mean.SC", "type" )

#this DF is empty
SC_Mus.female_no.rank$type <- "sim_no.rank"
colnames(SC_Mus.female_no.rank) <- c("SC.cV", "tot.SC", "mean.SC", "type" )

real_SC.Mus_female <- data.frame(female.biv.count_table$var_sc,  female.biv.count_table$total.SC, female.biv.count_table$mean_sc )
real_SC.Mus_female$type <- "real"

colnames(real_SC.Mus_female) <- c("SC.cV", "tot.SC", "mean.SC", "type")
#merge
SC_Mus_female <- rbind(SC_Mus.female_w.rank, SC_Mus.female_no.rank, real_SC.Mus_female)

Mus_SC_density_female <- ggplot(SC_Mus_female, aes(x = tot.SC, fill=type) )+geom_density(alpha=.6) + ggtitle("Total SC per cell, Mus female")


Mus_SC_density_female


```



```{r sum.stat.SClength, echo=FALSE}

#Calq SC cV for the SC length FEMALE
SCcv.val.DF_rank.female <- data.frame(  cV = rep(0, length(BIG.LIST_w.rank_female) ) ) #first initialize the DF results will go in outside of loop
for(j in 1:length(BIG.LIST_w.rank_female)){  #inside loop, move thru the LISTs of DFs
  #print(j)
  #fill in the cells of given index
  SCcv.val.DF_rank.female$cV[j] <-cv(  BIG.LIST_w.rank_female[[j]]$SC.length ) #for each
  }

#Calq SC cV for no rank
SCcv.val.DF_no.rank.female <- data.frame(  cV = rep(0, length(BIG.DF.LIST_no.rank_female) ) ) #first initialize the DF results will go in outside of loop
for(i in 1:length(BIG.DF.LIST_no.rank_female)){  #inside loop, move thru the LISTs of DFs
  #print(i)
  #fill in the cells of given index
  SCcv.val.DF_no.rank.female$cV[i] <-cv(  BIG.DF.LIST_no.rank_female[[i]]$SC.length ) #for each 
}

#merge + plots of the cvs
#10 and 10 rows from the permuted
SCcv.val.DF_rank.female$type <- "sim w.rank"
colnames(SCcv.val.DF_rank.female) <- c("cV","type" )

SCcv.val.DF_no.rank.female$type <- "sim no rank"
colnames(SCcv.val.DF_no.rank.female) <- c("cV", "type")

#then add the real values
real.vals.cv.SC_female <- data.frame(female.biv.count_table$cv_SC.length)
real.vals.cv.SC_female$type <- "real"
colnames(real.vals.cv.SC_female) <- c("cV", "type")

#merge and plots
cV.SC_permutations.DF_female <- rbind(SCcv.val.DF_rank.female, SCcv.val.DF_no.rank.female, real.vals.cv.SC_female)

#MALE --BIG.LIST_w.rank, BIG.DF.LIST_no.rank,
#Calq cV for the SC length
SCcv.val.DF_rank.male <- data.frame(  cV = rep(0, length(BIG.LIST_w.rank) ) ) #first initialize the DF results will go in outside of loop
for(j in 1:length(BIG.LIST_w.rank)){  #inside loop, move thru the LISTs of DFs
  #print(j)
  #fill in the cells of given index
  SCcv.val.DF_rank.male$cV[j] <-cv(  BIG.LIST_w.rank[[j]]$SC.length ) #for each
  }

#Calq cV for no rank
SCcv.val.DF_no.rank.male <- data.frame(  cV = rep(0, length(BIG.DF.LIST_no.rank) ) ) #first initialize the DF results will go in outside of loop
for(i in 1:length(BIG.DF.LIST_no.rank)){  #inside loop, move thru the LISTs of DFs
  #print(i)
  #fill in the cells of given index
  SCcv.val.DF_no.rank.male$cV[i] <-cv(  BIG.DF.LIST_no.rank[[i]]$SC.length ) #for each 
}

#merge + plots of the cvs
#10 and 10 rows from the permuted
SCcv.val.DF_rank.male$type <- "sim w.rank"
colnames(SCcv.val.DF_rank.male) <- c("cV","type" )

SCcv.val.DF_no.rank.male$type <- "sim no rank"
colnames(SCcv.val.DF_no.rank.male) <- c("cV", "type")

#then add the real values-- male.biv.count_table
real.vals.cv.SC_male <- data.frame(male.biv.count_table$cv_SC.length)
real.vals.cv.SC_male$type <- "real"
colnames(real.vals.cv.SC_male) <- c("cV", "type")

#merge and plots
cV.SC_permutations.DF_male <- rbind(SCcv.val.DF_rank.male, SCcv.val.DF_no.rank.male, real.vals.cv.SC_male)
cV.SC_permutations.DF_male$sex <- "male"
cV.SC_permutations.DF_female$sex <- "female"  #cV.SC_permutations.DF_female
all_cv.SC <- rbind(cV.SC_permutations.DF_female, cV.SC_permutations.DF_male)

cV.SC_plot <- ggplot(all_cv.SC, aes(y = cV, x=type) )+ geom_jitter()+ ggtitle("cv of within cell SC lengths")+facet_wrap(~sex)
```


The distribution of the female SC lengths isn't normal. Double check these values -- if their hand measured, not sure why 1 has much lower sc lengths.

I think the difference in variance of the rank and non-rank suimulations shows that chromsomes effects play a bigger role in shaping the distributions of cell wide SC area.



# CO Position

I think new randomized DFs must be made (male.whole.cell.min, not the DF.list)
(previous ones made lists of DFs, which were made of simulated DFs for each nucleus/cell)
My current code for position data, takes the current real DF, adds new columns with random draws of relative CO positions.

I am still working on the metrics to compare (and the ones that are best for cell wide descriptions).
- cell wide telomere bias
- cell wide rbar (smaller values mean more equal chrm proportions between foci. )
- average IFD

(should these metrics should be weighted by CO count?)

-measure the CO-variation of metrics within cells!
for each cell, make even-rank and odd-rank columns of rbar or another metric. Measure covariance of the 2 sets of pairs (real and random, even-odd).

## Male CO Position

Comparing cell wide statistics for CO position metrics across the real and randomized data sets.

The permuted/randomized data set is made by keeping CO count and SC lengths constant, but replacing the normalized foci position with a random normalized foci position(s) drawn from a pool of the same CO counts. The randomized relative positions are converted into raw/absolute positions (for the original SC length of that bivalent observation). 

```{r random.CO.pos, echo=FALSE}
#male.whole.cell
#female.whole.cell
#fix the data DF for PERMUTING CO

whole.cell.data <- whole.cell.data[(whole.cell.data$hand.foci.count!="XY"), ]
male.whole.cell <- whole.cell.data[whole.cell.data$sex == "male", ]#359

male.biv.count_table <- male.biv.count_table[!(is.na(male.biv.count_table$fileName) | male.biv.count_table$fileName==""), ]

male.whole.cell <- male.whole.cell[!(is.na(male.whole.cell$fileName) | male.whole.cell$fileName==""), ]

#make sure male.whole.cell has nrm oci positions
pos.pool_1CO <- male.whole.cell[male.whole.cell$hand.foci.count == 1,]
pos.pool_2CO <- male.whole.cell[male.whole.cell$hand.foci.count == 2,]
pos.pool_3CO <- male.whole.cell[male.whole.cell$hand.foci.count == 3,]

pos.pool_1CO <- pos.pool_1CO[!(is.na(pos.pool_1CO$fileName) | pos.pool_1CO$fileName==""), ]
pos.pool_2CO <- pos.pool_2CO[!(is.na(pos.pool_2CO$fileName) | pos.pool_2CO$fileName==""), ]
pos.pool_3CO <- pos.pool_3CO[!(is.na(pos.pool_3CO$fileName) | pos.pool_3CO$fileName==""), ]
#now make the randomized data set for CO pos
#do whole row -- so I can cen n


#make a copy of main DF
male.whole.cell.mini <- male.whole.cell

#filling in with randomized foci positions
for(oar in 1:length(male.whole.cell.mini$fileName)){
 # print(oar)
   if(male.whole.cell.mini$hand.foci.count[oar] == 1){
    #print("oner")
     #random sample -- there could be replicates in the random sample
     rand.obj.id.1CO <- sample(pos.pool_1CO$Obj.ID, 1)
     
     male.whole.cell.mini$rand.ID[oar] <- rand.obj.id.1CO
     male.whole.cell.mini$rand.Foci1[oar] <- as.numeric(pos.pool_1CO$Foci1.PER[which(pos.pool_1CO$Obj.ID == rand.obj.id.1CO)])
     #  sample(pos.pool_1CO$F1, 1, replace = FALSE)
     male.whole.cell.mini$rand.Foci2[oar] <- ""
     male.whole.cell.mini$rand.Foci3[oar] <- ""
   }
  
  if(male.whole.cell.mini$hand.foci.count[oar] == 2){
   # print("twoer")
    
    #random sampl of obj.id
    rand.obj.id <- sample(pos.pool_2CO$Obj.ID, 1)
    
    male.whole.cell.mini$rand.ID[oar] <- rand.obj.id
    #asign the F1s and F2s from the fit obj.id
    
    male.whole.cell.mini$rand.Foci1[oar] <-as.numeric(pos.pool_2CO$Foci1.PER[which(pos.pool_2CO$Obj.ID == rand.obj.id)])
  #  male.whole.cell.mini$rand.Foci2[oar] <- "blah"
    male.whole.cell.mini$rand.Foci2[oar] <-as.numeric(pos.pool_2CO$Foci2.PER[which(pos.pool_2CO$Obj.ID == rand.obj.id)])
    male.whole.cell.mini$rand.Foci3[oar] <- ""
 }

  if(male.whole.cell.mini$hand.foci.count[oar] == 3){
   # print("threer")
    rand.obj.id_3co <- sample(pos.pool_3CO$Obj.ID, 1)
    
    male.whole.cell.mini$rand.ID[oar] <- rand.obj.id_3co

        male.whole.cell.mini$rand.Foci1[oar] <-as.numeric(pos.pool_3CO$Foci1.PER[which(pos.pool_3CO$Obj.ID == rand.obj.id_3co)])
  #  male.whole.cell.mini$rand.Foci2[oar] <- "blah"
    male.whole.cell.mini$rand.Foci2[oar] <-as.numeric(pos.pool_3CO$Foci2.PER[which(pos.pool_3CO$Obj.ID == rand.obj.id_3co)])
    
    male.whole.cell.mini$rand.Foci3[oar] <-as.numeric(pos.pool_3CO$Foci3.PER[which(pos.pool_3CO$Obj.ID == rand.obj.id_3co)])
    
  }
    
}

male.whole.cell.mini$SC.length <- as.numeric(as.character(male.whole.cell.mini$SC.length))
male.whole.cell.mini$rand.Foci2 <- as.numeric(as.character(male.whole.cell.mini$rand.Foci2))
male.whole.cell.mini$rand.Foci3 <- as.numeric(as.character(male.whole.cell.mini$rand.Foci3))

male.whole.cell.mini$raw.rand_Foci1 <- male.whole.cell.mini$rand.Foci1 * male.whole.cell.mini$SC.length
male.whole.cell.mini$raw.rand_Foci2 <- male.whole.cell.mini$rand.Foci2 * male.whole.cell.mini$SC.length
male.whole.cell.mini$raw.rand_Foci3 <- male.whole.cell.mini$rand.Foci3 * male.whole.cell.mini$SC.length

```


### calq within nuc COVARIATION

```{r even.odd, echo=FALSE}
#4 new columns for testing with in nuc covariance

#this doesn't works as well for male 19! (get ride of shortest?)
#make new DF (copy, or empty?)

covary.DF <- male.whole.cell.mini[male.whole.cell.mini$fileName == "1mar16_3jan16_G_m2_sp1_19.3_rev",]
#loop

#I HAVE to make sure they are all ordered by metric, or the pairing for cov() will not make sense

covary.DF <- with(covary.DF, covary.DF[order(SC.length),])
evens <- covary.DF[which(covary.DF$rank %% 2 == 0),]
odds <- covary.DF[which(covary.DF$rank %% 2 != 0),]
cov(evens$SC.length,odds$SC.length[2:10])#303 (lots of variance)
cor(evens$SC.length,odds$SC.length[2:10])# 0.2480786
#do this for each cell / filename

#covary, rbar -- within the same nuc
#real and rand cov
for(y in 1:length(covary.DF$fileName)  ){
  covary.DF$rbar[y] <- calq.intra.rbar(covary.DF[y,])
}



covary.DF <- with(covary.DF, covary.DF[order(rbar),])
evens <- covary.DF[which(covary.DF$rank %% 2 == 0),]
odds <- covary.DF[which(covary.DF$rank %% 2 != 0),]

cov(evens$rbar,odds$rbar[2:10])#0.007357481
cor(evens$rbar,odds$rbar[2:10])# 0.9734986
#I don't know how to interpert the scales of the covariaition values...
#correlation is simpler to me

#male.whole.cell.mini
#counter of file 


for(y in 1:length(male.whole.cell.mini$fileName)  ){
  male.whole.cell.mini$rbar[y] <- calq.intra.rbar(male.whole.cell.mini[y,])
}
for(rr in 1:length(male.whole.cell.mini$fileName)  ){
  male.whole.cell.mini$rand.rbar[rr] <- calq.intra.rbar_rand(male.whole.cell.mini[rr,])
}


#make smaller cell.level DF
smllr.list = data.frame(fileName = unique(male.whole.cell.mini$fileName))
i = 1
#the loop isn't cycling
for(each in unique(male.whole.cell.mini$fileName) ) {
 # print(each)
  
  #make smaller DF, list of all obs of that file
  temp.Df = male.whole.cell.mini[ male.whole.cell.mini$fileName == each,]
  ordered.DF.rbar = with(temp.Df, temp.Df[order(rbar),])

  #order by the metric (SC,rbar)  #make list of even and odd
  evens <- ordered.DF.rbar$rbar[which(ordered.DF.rbar$rank %% 2 == 0)]
  odds <- ordered.DF.rbar$rbar[which(ordered.DF.rbar$rank %% 2 != 0)]
  
  evens.rand <- ordered.DF.rbar$rand.rbar[which(ordered.DF.rbar$rank %% 2 == 0)]
  odds.rand <- ordered.DF.rbar$rand.rbar[which(ordered.DF.rbar$rank %% 2 != 0)]

  #calq cor,cov
  smllr.list$fileName[i] <- each
  smllr.list$cov[i] <- cov(evens,odds[2:10])
  smllr.list$cor[i] <- cor(evens,odds[2:10])
  
  smllr.list$cov.rand[i] <- cov(evens.rand, odds.rand[2:10])
  smllr.list$cor.rand[i] <- cor(evens.rand, odds.rand[2:10])
  
  #print(i)
  i = i+1
  }

#plotty <- ggplot(smllr.list, #aes(x=cov,y=cov.rand))+geom_jitter()+xlim(c(-.005,.006))+ylim(c(-.005,.006))

  
```


Calq the within cell covariance for the true and randomized values. 
Not sure how to use them yet


### merge melt data

don't use melt data

```{r melt.data,echo=FALSE}


#melt the nrmfoci.pos, for real and randomized data
REAL.melt.whole.cell.mini <- melt(male.whole.cell.mini,
              c("Obj.ID","SC.length", "hand.foci.count","Foci1.PER","Foci2.PER","Foci3.PER"),
                                  
              id=c("Obj.ID","SC.length", "hand.foci.count")
                                  )
REAL.melt.whole.cell.mini <- REAL.melt.whole.cell.mini[!(is.na(REAL.melt.whole.cell.mini$value) | REAL.melt.whole.cell.mini$value==""), ]

REAL.melt.whole.cell.mini <- REAL.melt.whole.cell.mini[ (REAL.melt.whole.cell.mini$variable != "hand.foci.count"), ]
REAL.melt.whole.cell.mini <- REAL.melt.whole.cell.mini[ (REAL.melt.whole.cell.mini$variable != "Obj.ID"), ]
REAL.melt.whole.cell.mini <- REAL.melt.whole.cell.mini[ (REAL.melt.whole.cell.mini$variable != "SC.length"), ]

#make random melted DF
RAND.melt.whole.cell.mini <- melt(male.whole.cell.mini, c("rand.ID","SC.length","hand.foci.count","rand.Foci1","rand.Foci2","rand.Foci3"),
                                  id=c("rand.ID", "SC.length","hand.foci.count")
)
RAND.melt.whole.cell.mini <- RAND.melt.whole.cell.mini[!(is.na(RAND.melt.whole.cell.mini$value) | RAND.melt.whole.cell.mini$value==""), ]

RAND.melt.whole.cell.mini <- RAND.melt.whole.cell.mini[ (RAND.melt.whole.cell.mini$variable != "hand.foci.count"), ]
RAND.melt.whole.cell.mini <- RAND.melt.whole.cell.mini[ (RAND.melt.whole.cell.mini$variable != "rand.ID"), ]
RAND.melt.whole.cell.mini <- RAND.melt.whole.cell.mini[ (RAND.melt.whole.cell.mini$variable != "SC.length"), ]




```



```{r merge.real.rand, echo=FALSE}

REAL.melt.whole.cell.mini$type <- "real"
RAND.melt.whole.cell.mini$type <- "sim"

colnames(RAND.melt.whole.cell.mini) <- c("Obj.ID","SC.length", "hand.foci.count","variable","value", "type" )

Position.DF <- rbind(REAL.melt.whole.cell.mini,RAND.melt.whole.cell.mini)

Position.DF$value <- as.numeric(Position.DF$value )
Position.DF$SC.length <- as.numeric(Position.DF$SC.length )

```


```{r maw.blah, echo=FALSE}
#cell.wide.rbar
#calq telo distnce
source("~./MLH1repo/src/CommonFunc_MLH1repo.R")

for(y in 1:length(male.whole.cell.mini)  ){
  male.whole.cell.mini$rbar[y] <- calq.intra.rbar(male.whole.cell.mini[y,])
}

for(rr in 1:length(male.whole.cell.mini)  ){
  male.whole.cell.mini$rand.rbar[rr] <- calq.intra.rbar_rand(male.whole.cell.mini[rr,])
}

#make a new DF
#
real_rbar.Mus <- data.frame(male.whole.cell.mini$rbar )
real_rbar.Mus$type <- "real"
colnames(real_rbar.Mus) <- c("rbar", "type" )

rand_rbar.Mus <- data.frame(male.whole.cell.mini$rand.rbar )
rand_rbar.Mus$type <- "rand"
colnames(rand_rbar.Mus) <- c("rbar",  "type" )

#merge
Mus_rbar_male <- rbind(rand_rbar.Mus, real_rbar.Mus)

dense1 <- ggplot(real_rbar.Mus, aes(x = rbar, fill=type) )+geom_density(alpha=.6)


#
density.plot_rbars <- ggplot(Mus_rbar_male, aes(x = rbar, fill=type) )+geom_density(alpha=.6) + ggtitle("Bivalent Rbar distributions, Mus male")+xlim(c(0,.55))
density.plot_rbars

mapp.cell.wide_cells <-  ddply(.data=male.whole.cell.mini,
                 .(fileName),
                 summarize,
                 nbiv = length(SC.length),
                 tot.SC = sum(SC.length),

                var.raw = var(c(Foci1,Foci2, Foci3), na.rm=TRUE ),
                var.raw.rand = var( c(raw.rand_Foci1,raw.rand_Foci2,raw.rand_Foci3), na.rm=TRUE ),
               
                mean_rbar = mean(rbar),
                mean_rand.rbar = mean(rand.rbar),
                sum_rbar = sum(rbar),
                sum_rand.rbar = sum(rand.rbar)
                
)

real_cellwide_rbar.Mus <- data.frame(mapp.cell.wide_cells$mean_rbar )
real_cellwide_rbar.Mus$type <- "real"
colnames(real_cellwide_rbar.Mus) <- c("rbar", "type" )

rand_cellwide_rbar.Mus <- data.frame(mapp.cell.wide_cells$mean_rand.rbar )
rand_cellwide_rbar.Mus$type <- "rand"
colnames(rand_cellwide_rbar.Mus) <- c("rbar",  "type" )

#merge
cell.wide.Mus_rbar_male <- rbind(real_cellwide_rbar.Mus, rand_cellwide_rbar.Mus)

#
density.plot_cell.wide.rbars <- ggplot(cell.wide.Mus_rbar_male, aes(x = rbar, fill=type) )+geom_density(alpha=.6) + ggtitle("Cell wide mean Rbar distributions, Mus male")+xlim(c(0,.3))
density.plot_cell.wide.rbars



real_tot.cell_rbar.Mus <- data.frame(mapp.cell.wide_cells$sum_rbar )
real_tot.cell_rbar.Mus$type <- "real"
colnames(real_tot.cell_rbar.Mus) <- c("sum.rbar", "type" )

rand_tot.cell_rbar.Mus <- data.frame(mapp.cell.wide_cells$sum_rand.rbar )
rand_tot.cell_rbar.Mus$type <- "rand"
colnames(rand_tot.cell_rbar.Mus) <- c("sum.rbar",  "type" )
#merge
cell.wide.tot.rbar_Musmale <- rbind(real_tot.cell_rbar.Mus, rand_tot.cell_rbar.Mus)


#
density.plot_cell.wide.rbars <- ggplot(cell.wide.tot.rbar_Musmale, aes(x = sum.rbar, fill=type) )+geom_density(alpha=.6) + ggtitle("Cell wide total Rbar distributions, Mus male")+xlim(c(0,6))

density.plot_cell.wide.rbars


```

The random relative foci positions were 'mapped' onto each of the SC length observations (foci * SC.length). 

The first plot shows the 2 disttributions of all the rbar measures (across all bivalents)
The second plot shows the mean rbar for the whole cell




```{r relative.foci.Pos.plot, echo=FALSE}

#mapp.cell.wide_cells
#density or histogram plot facet hand foci count, plot value, fill type
pos.plot <- ggplot(Position.DF[Position.DF$hand.foci.count == 1,], aes(x=as.numeric(value), fill=type))+geom_density(alpha=.6)

pos.plot <- ggplot(Position.DF[Position.DF$hand.foci.count == 1,], aes(x=as.numeric(value), fill=type))+geom_histogram()


pos.plot.all <- ggplot(Position.DF, aes(x=as.numeric(value), fill=type))+geom_density(alpha=.6)+facet_wrap(~hand.foci.count,ncol = 1)+ggtitle("Simulated and real normalized positions, male mus")
pos.plot.all

pos.plot.one <- ggplot(Position.DF[Position.DF$hand.foci.count == 2,], aes(x=as.numeric(value), fill=type))+geom_density(alpha=.6)+facet_wrap(~hand.foci.count)+ggtitle("Simulated and real normalized positions")
```

The above distributions of relative foci position compare the real data pink to randomized data set of relative positions where for each bivalent observations the normalized position was replaced with positions from a randomly draw bivalent with the same CO number. For multi co bivalents relative foci positions were kept together. For example, a random 2CO bivalent chosen and the normalize foci1 and foci2 for that bivalent were used.
In terms of normalized foci positions, the empirical distribution isn't very different from a randomized distribution. Not exactly sure if this is the right randomization procedure, the same 'random' bivalent could be drawn more than once.



I might write in a way to account for rank, to account for how the relative foci positions vary for short and long chromosomes. but for now, just simulate across the whole/full pool.




```{r map.rand2real, echo=FALSE, warning=FALSE}

#need sc length from the original
Position.DF$raw.foci.pos <- Position.DF$SC.length * Position.DF$value

male.whole.cell.mini$rand.Foci2 <- as.numeric(male.whole.cell.mini$rand.Foci2)
male.whole.cell.mini$rand.Foci3 <- as.numeric(male.whole.cell.mini$rand.Foci3)

male.whole.cell.mini$raw.rand_Foci1 <- male.whole.cell.mini$SC.length *male.whole.cell.mini$rand.Foci1
male.whole.cell.mini$raw.rand_Foci2 <- male.whole.cell.mini$SC.length *male.whole.cell.mini$rand.Foci2
male.whole.cell.mini$raw.rand_Foci3 <- male.whole.cell.mini$SC.length *male.whole.cell.mini$rand.Foci3


#calq telo distnce
source("~./MLH1repo/src/CommonFunc_MLH1repo.R")

for(y in 1:length(male.whole.cell.mini)  ){
  male.whole.cell.mini$rbar[y] <- calq.intra.rbar(male.whole.cell.mini[y,])
}

for(rr in 1:length(male.whole.cell.mini)  ){
  male.whole.cell.mini$rand.rbar[rr] <- calq.intra.rbar_rand(male.whole.cell.mini[rr,])
}



#cell wide telomere covariance bias
mapp.cell.wide <-  ddply(.data=male.whole.cell.mini,
                 .(fileName, hand.foci.count),
                 summarize,
                 nbiv = length(SC.length),
                 tot.SC = sum(SC.length),
                 mean.pos = mean(Foci1.PER),
                 mean.rand.pos = mean(rand.Foci1),
                 mean.raw = mean(c(Foci1,Foci2, Foci3), na.rm=TRUE ),
                 mean.raw.rand = mean( c(raw.rand_Foci1,raw.rand_Foci2,raw.rand_Foci3), na.rm=TRUE ),
                 
                var.raw = var(c(Foci1,Foci2, Foci3), na.rm=TRUE ),
                 var.raw.rand = var( c(raw.rand_Foci1,raw.rand_Foci2,raw.rand_Foci3), na.rm=TRUE ),
               
                mean_rbar = mean(rbar),
                mean_rand.rbar = mean(rand.rbar)
)

mapp.cell.wide <- add_mouse(mapp.cell.wide)
mapp.cell.wide <- add_strain(mapp.cell.wide)


maisel <- ggplot(mapp.cell.wide, aes(x=mean_rbar, y=mean_rand.rbar))+geom_point()+xlim(c(0,.3))+ylim(c(0,.3))+ggtitle("cell wide randomized rbar vs empiracal rbar")
maisel

oopp <- ggplot(mapp.cell.wide, aes(y=mean.raw, x=mean.raw.rand, color=mouse) ) +geom_point()+ggtitle("average foci position by cell, real vs randomized")


hh <- ggplot(mapp.cell.wide, aes(y=var.raw,x=var.raw.rand) ) +geom_point()+ggtitle("variance in foci position (per cell), between real and randomized")


```

distributions don't look different. 
Since I randomized the cell effect -- I need to map back into a cell wide summary to effectively compare the differences.

NEED to Calculate cell-wide telomere bias (use a ddplyr thing)

some of the plots compare the cell wide measures from real and randomized (I think this difference is what I should calculate for permuting or randomizing)

points closer to 1:1 line have foci position features near the average of the group


the random r bar is higher than the real r bar positions. meaning on average the male cell rbar values are lower (less to the middle and more to the ends) -- would this be the same as in female cells?

we calculated the intra-chromosomal portion of rbar (Veller et al., 2019) to compare how evenly crossovers were spaced while accounting for raw SC length. This metric ranges from 0 to 0.5, with higher values indicating that SC proportions flanking crossovers are more equivalent.

My randomized plots indicate that the real chromosome measures have more 'unequal' chromsome portions flanking COs.


```{r sum.stat.CO.pos, echo=FALSE}
#remove F1 without values
#and 1CO with 2 values

SC_Mus.male_w.rank <- data.frame(  SC.cv = rep(0, length(BIG.LIST_w.rank) ) ) #first initialize the DF results will go in outside of loop
for(j in 1:length(BIG.LIST_w.rank)){  #inside loop, move thru the LISTs of DFs
 # print(j)
  #fill in the cells of given index
  SC_Mus.male_w.rank$SC.cv[j] <-cv(  BIG.LIST_w.rank[[j]]$SC.length ) #for each
  SC_Mus.male_w.rank$total_SC[j] <-sum(  BIG.LIST_w.rank[[j]]$SC.length )
  SC_Mus.male_w.rank$mean_SC[j] <-mean(  BIG.LIST_w.rank[[j]]$SC.length )
  }

#Calq cV for no rank
SC_Mus.male_no.rank <- data.frame(  cV = rep(0, length(BIG.DF.LIST_no.rank) ) ) #first initialize the DF results will go in outside of loop
for(i in 1:length(BIG.DF.LIST_no.rank)){  #inside loop, move thru the LISTs of DFs
  #print(i)
  #fill in the cells of given index
  SC_Mus.male_no.rank$cV[i] <-cv(  BIG.DF.LIST_no.rank[[i]]$SC.length )
  SC_Mus.male_no.rank$total_SC[i] <-sum(  BIG.DF.LIST_no.rank[[i]]$SC.length )
  SC_Mus.male_no.rank$mean_SC[i] <-mean(  BIG.DF.LIST_no.rank[[i]]$SC.length )
}

```



## Female CO Position Comparison

For now stick with rbar, since it's a metric I can use across chromosome classes.

1. randomized
2. calq rbar values
3. merge mini.DFs
4. plot


```{r Female.CO.pos, echo=FALSE}
#female.whole.cell

female.whole.cell <- whole.cell.data[whole.cell.data$sex == "female", ]
female.biv.count_table <- female.biv.count_table[!(is.na(female.biv.count_table$fileName) | female.biv.count_table$fileName==""), ]
female.whole.cell <- female.whole.cell[!(is.na(female.whole.cell$fileName) | female.whole.cell$fileName==""), ]


#make sure male.whole.cell has nrm oci positions
F_pos.pool_1CO <- female.whole.cell[female.whole.cell$hand.foci.count == 1,]
F_pos.pool_2CO <- female.whole.cell[female.whole.cell$hand.foci.count == 2,]
F_pos.pool_3CO <- female.whole.cell[female.whole.cell$hand.foci.count == 3,]

F_pos.pool_1CO <- F_pos.pool_1CO[!(is.na(F_pos.pool_1CO$fileName) | F_pos.pool_1CO$fileName==""), ]
F_pos.pool_2CO <- F_pos.pool_2CO[!(is.na(F_pos.pool_2CO$fileName) | F_pos.pool_2CO$fileName==""), ]
F_pos.pool_3CO <- F_pos.pool_3CO[!(is.na(F_pos.pool_3CO$fileName) | F_pos.pool_3CO$fileName==""), ]

#make a copy of main DF
female.whole.cell.mini <- female.whole.cell


female.whole.cell.mini$Foci1 <- female.whole.cell.mini$F1
female.whole.cell.mini$Foci2 <- female.whole.cell.mini$F2
female.whole.cell.mini$Foci3 <- female.whole.cell.mini$F3

#filling in with randomized foci positions
for(oar in 1:length(female.whole.cell.mini$fileName)){
 #print(oar)
   
  if(female.whole.cell.mini$hand.foci.count[oar] == 0){
     # print("zero")
      female.whole.cell.mini$rand.ID[oar] <- ""
     female.whole.cell.mini$rand.Foci1[oar] <- ""  
    female.whole.cell.mini$rand.Foci2[oar] <- ""
     female.whole.cell.mini$rand.Foci3[oar] <- ""
  }
  
  if(female.whole.cell.mini$hand.foci.count[oar] == 1){
     # print("oner")
     rand.obj.id.1CO <- sample(F_pos.pool_1CO$Obj.ID, 1, replace = FALSE)
     female.whole.cell.mini$rand.ID[oar] <- rand.obj.id.1CO
     female.whole.cell.mini$rand.Foci1[oar] <- as.numeric(F_pos.pool_1CO$Foci1.PER[which(F_pos.pool_1CO$Obj.ID == rand.obj.id.1CO)])

     female.whole.cell.mini$rand.Foci2[oar] <- ""
     female.whole.cell.mini$rand.Foci3[oar] <- ""
   }
  
  if(female.whole.cell.mini$hand.foci.count[oar] == 2){
  #  print("twoer")
    rand.obj.id.2CO <- sample(F_pos.pool_2CO$Obj.ID, 1, replace = FALSE)
    female.whole.cell.mini$rand.ID[oar] <- rand.obj.id.2CO
    #asign the F1s and F2s from the fit obj.id
    
    female.whole.cell.mini$rand.Foci1[oar] <-as.numeric(F_pos.pool_2CO$Foci1.PER[which(F_pos.pool_2CO$Obj.ID == rand.obj.id.2CO)])
    female.whole.cell.mini$rand.Foci2[oar] <-as.numeric(F_pos.pool_2CO$Foci2.PER[which(F_pos.pool_2CO$Obj.ID == rand.obj.id.2CO)])
    female.whole.cell.mini$rand.Foci3[oar] <- ""
 }

  if(female.whole.cell.mini$hand.foci.count[oar] == 3){
    #print("threer")
    rand.obj.id_3co <- sample(F_pos.pool_3CO$Obj.ID, 1, replace = FALSE)
    
    female.whole.cell.mini$rand.ID[oar] <- rand.obj.id_3co
        female.whole.cell.mini$rand.Foci1[oar] <-as.numeric(F_pos.pool_3CO$Foci1.PER[which(F_pos.pool_3CO$Obj.ID == rand.obj.id_3co)])
    female.whole.cell.mini$rand.Foci2[oar] <-as.numeric(F_pos.pool_3CO$Foci2.PER[which(F_pos.pool_3CO$Obj.ID == rand.obj.id_3co)])
    female.whole.cell.mini$rand.Foci3[oar] <-as.numeric(F_pos.pool_3CO$Foci3.PER[which(F_pos.pool_3CO$Obj.ID == rand.obj.id_3co)])
  }
  }
#I keep drawing the same chrm for many of the 3COs -- not sure how to fix this / get around this


```



```{r female.rbar, echo=FALSE, warning=FALSE}

female.whole.cell.mini$SC.length <- as.numeric(as.character(female.whole.cell.mini$SC.length))
female.whole.cell.mini$rand.Foci1 <- as.numeric(as.character(female.whole.cell.mini$rand.Foci1))
female.whole.cell.mini$rand.Foci2 <- as.numeric(as.character(female.whole.cell.mini$rand.Foci2))
female.whole.cell.mini$rand.Foci3 <- as.numeric(as.character(female.whole.cell.mini$rand.Foci3))

female.whole.cell.mini$raw.rand_Foci1 <- female.whole.cell.mini$rand.Foci1 * female.whole.cell.mini$SC.length
female.whole.cell.mini$raw.rand_Foci2 <- female.whole.cell.mini$rand.Foci2 * female.whole.cell.mini$SC.length
female.whole.cell.mini$raw.rand_Foci3 <- female.whole.cell.mini$rand.Foci3 * female.whole.cell.mini$SC.length

#female.whole.cell.mini
for(y in 1:length(female.whole.cell.mini$fileName)  ){
  
  female.whole.cell.mini$rbar[y] <- calq.intra.rbar(female.whole.cell.mini[y,])
}

for(rr in 1:length(female.whole.cell.mini$fileName)  ){
  female.whole.cell.mini$rand.rbar[rr] <- calq.intra.rbar_rand(female.whole.cell.mini[rr,])
}
#don't know why there's so many 0 rbar values


#make a new DF
real_rbar.Female.Mus <- data.frame(female.whole.cell.mini$rbar )
real_rbar.Female.Mus$type <- "real"
colnames(real_rbar.Female.Mus) <- c("rbar", "type" )

rand_rbar.Female.Mus <- data.frame(female.whole.cell.mini$rand.rbar )
rand_rbar.Female.Mus$type <- "rand"
colnames(rand_rbar.Female.Mus) <- c("rbar",  "type" )

#merge
Mus_rbar_female <- rbind(real_rbar.Female.Mus, rand_rbar.Female.Mus)

#
density.plot_rbars_female <- ggplot(Mus_rbar_female, aes(x = rbar, fill=type) )+geom_density(alpha=.6) + ggtitle("Bivalent Rbar distributions, Mus female")+xlim(c(0,.3))
density.plot_rbars_female


female.whole.cell.mini <- female.whole.cell.mini[female.whole.cell.mini$rbar > -.1,]
#
scatter_rbars_female <- ggplot(female.whole.cell.mini, aes(y = rbar, x= as.factor(fileName)) )+geom_jitter()+ ggtitle("Mus female rbar scatter plot")

```


Not sure why real distribution is more smooth compared to the random.
The female rbar measures are closer to the maxium of 0.5, where all foci are placed equally along the chromsomes.


## Adding to Data set

how to best increase the size of the data set, with my bivalent data. From the curated BivData, figure out which can be added / into the whole cell data. I think there might only be a couple cell to add in.

```{r getting.cell.names, echo=FALSE,eval=FALSE}

#load in the cell dataset
#28feb15_PWD_f2  from Curated_BivData
#for a mouse, pull the 10 highest rec cells

PWD.female_hand.measure = read.csv("~./MLH1repo/data/BivData/PWD_female_hand_measure.csv", header = TRUE, strip.white = TRUE)
#"fileName"                "boxNumber"               "blobjectClass"           "chromosomeLength"        "centromere_ABS_Position" "Foci1"                   "Foci2"                  
#"Foci3"                   "curation.notes"  
female.mouse_bivData <- Curated_BivData[Curated_BivData$mouse == "28feb15_PWD_f2",]

write.table(female.mouse_bivData, "~./MLH1repo/28feb15_PWD_f2.csv", sep=",", row.names = FALSE)

PWD.female_hand.measure = read.csv("~./MLH1repo/28feb15_PWD_f2.csv", header = TRUE, strip.white = TRUE)
PWD.female_hand.measure$Obj.ID <- paste(PWD.female_hand.measure$fileName, PWD.female_hand.measure$boxNumber, sep = "_")

#merge with hand data
#mergy <- merge(PWD.female_hand.measure, female.mouse_bivData)
#PWD.female_hand.measure$hand.foci.count <- as.numeric(PWD.female_hand.measure$hand.foci.count)


cells.BivData_table_28feb15_PWD_f2 <- ddply(.data=PWD.female_hand.measure, 
                            .(fileName),
                            summarize, 
                            ncells = length(unique(fileName)),
                            nbivs = length(unique(Obj.ID)),
                            n.foci = sum(hand.foci.count),
                            total.SC = sum(chromosomeLength),
                            mean.SC = mean(chromosomeLength)
                            
)
#add hand data
ll <- cells.BivData_table_28feb15_PWD_f2[cells.BivData_table_28feb15_PWD_f2$nbivs > 18,]

#I have 3 cells with full 20

```

```{r mini.biv, echo=FALSE,eval=FALSE}
#make mini biv plots

#PWD.female
#PWD.female_hand.measure

cell.1 <- PWD.female_hand.measure[PWD.female_hand.measure$fileName == "13mar15_28feb15_PWD_f2_sp1_10_rev",]
cell.2 <- PWD.female_hand.measure[PWD.female_hand.measure$fileName == "13mar15_28feb15_PWD_f2_sp1_38_rev",]


two_groups <- transform(cell.1, category2 = factor(paste(fileName, chromosomeLength)))
two_groups <- transform(two_groups, category2 = reorder(category2, rank(chromosomeLength)))

#this plot function takes the new df, and plots cat2(x) by SC length (y). cat2 has been ordered by the ranked length
#of SC.
MiniBiv_plot1 <-  ggplot(two_groups, aes(category2, chromosomeLength)) +
    geom_bar(aes(fill= as.factor(hand.foci.count)), stat = "identity") +
  #  geom_vline(xintercept = c(male_IFD, 1) ) +  #
 #geom_hline(yintercept = c(male_IFD) ) +
  
  scale_fill_manual(values=c("red", "red", "red")) +   #0CO;"#FFCC66"
  #how to add points for 2foci
  geom_point(aes(x=two_groups$category2, y=two_groups$Foci1),colour = "green",size = 3 ) +   
  #foci.1.position, two_groups$distal.foci.position)
  geom_point(aes(x=two_groups$category2, y=two_groups$Foci2),colour = "green",size = 3 ) +
  
#add centromeres...  
  geom_point(aes(x=two_groups$category2, y=0), colour = "purple4",size =5)+


  facet_wrap( ~ fileName, scales = "free_x", ncol = 5) +
 # scale_x_discrete(labels=two_groups$strain, breaks=two_groups$category2) +
  ylim(c(0,200))+
     theme(axis.line=element_blank(),axis.text.x=element_blank(),
        axis.ticks=element_blank())  #for removeing x labels

#MiniBiv_plot1
#MiniBiv_plot2

#save the files 

```

```{r discribe.Biv.Pattern, echo=FALSE}
#start discribing the basic 

#start merging curated bivData with handmeasured data


#BivData - Curated
```

```{r add.more.whole.cell, echo=FALSE}

#load data curatedBiv Data
#load in hand measures


```


Look/use the DF, Curated_BivData data frame for mice with many cell measures and cells with whole cell measures (all bivalents have been measured).

Mice with many cells and BivData
17mar16_G_f4 - BivData
17mar16_G_f1

Chunk below has code for choosing mice with a good number of cells (25?)

```{r choosing.mice, echo=FALSE, eval=FALSE}
#Choose mice with many cell observations 
#important for increased power for within mouse variance

#G_f, G_m
#SKIVE_f, SKIVE_m #have BivData

#remove all the quality 5

#make plot/histogram of the MLH1 count distribution
counts <- MLH1_data$nMLH1.foci[MLH1_data$mouse == "31may19_SKIVE_f6"]

mouse.DF <- MLH1_data[MLH1_data$mouse == "31may19_SKIVE_f6",]
mouse.DF <- mouse.DF[mouse.DF$quality < 5,]
high.bin.DF <- mouse.DF[mouse.DF$nMLH1.foci>=quantile(counts, 0.9, na.rm=TRUE), ]
low.bin.DF <- mouse.DF[mouse.DF$nMLH1.foci<=quantile(counts, 0.1, na.rm=TRUE), ]

ordered.MLH1 <- mouse.DF[with(mouse.DF,order(nMLH1.foci)),]#this returns ordered
topsy <- ordered.MLH1[1:5,]
bottomzy <- ordered.MLH1[(length(ordered.MLH1$nMLH1.foci)-5):length(ordered.MLH1$nMLH1.foci),]
#now have top and bottom 5 cell observations 

#merge
top.n.bottom.bin <- rbind(topsy,bottomzy)

#write 
write.table(top.n.bottom.bin, "~./MLH1repo/curated.bins.csv", sep=",", row.names = FALSE)


shiz <- ggplot(data = MLH1_data[MLH1_data$mouse == "31may19_SKIVE_f6",],
       aes(x=nMLH1.foci))+geom_histogram(stat = "bin", binwidth = 1)+ggtitle("31may19_SKIVE_f6 Cell counts")+
geom_vline(xintercept = c(min(high.bin), max(low.bin)), color= "red")
#highest of the low bin
#lowest value of the high bin

#get the filenames for this groups of cells

#10mar15_PWD_m1#10mar15_PWD_m2 -- not found in BivData, re-running all of the PWD male data
#28feb15_PWD_f2, in PWD--female .xlsx file

#31may19_SKIVE_m2
male.one.DF <- MLH1_data[MLH1_data$mouse == "28feb15_PWD_f2",]
male.one.DF <- male.one.DF[male.one.DF$quality < 5,]

ordered.MLH1.male <- male.one.DF[with(male.one.DF,order(nMLH1.foci)),]#this returns ordered
male.high.bin.DF <- ordered.MLH1.male[1:5,]
male.low.bin.DF <- ordered.MLH1.male[(length(ordered.MLH1.male$nMLH1.foci)-5):length(ordered.MLH1.male$nMLH1.foci),]
#now have top and bottom 5 cell observations 

#merge
male.top.n.bottom.bin <- rbind(male.high.bin.DF, male.low.bin.DF)
#write 
write.table(male.top.n.bottom.bin, "~./MLH1repo/female.PWD.curated.bins.csv", sep=",", row.names = FALSE)


shiz.too <- ggplot(data = MLH1_data[MLH1_data$mouse == "31may19_SKIVE_m2",],
       aes(x=nMLH1.foci))+geom_histogram(stat = "bin", binwidth = 1)+ggtitle("31may19_SKIVE_m2 Cell counts")+
geom_vline(xintercept = c(min(male.high.bin.DF$nMLH1.foci), max(male.low.bin.DF$nMLH1.foci)), color= "red")
#highest of the low bin
#lowest value of the high bin
shiz.too


```


the plot above shows an example plot of --- where the pools are from, currently these are 10 quantille and 90 quantile. setting threshold by percentile doesn't always give enough cells. 
Should I be comparing cells with the same number of COs?



# Extra at the end


```{r junk, eval=FALSE, echo=FALSE}
DF.permutations <- data.frame( nuc.sim = seq(1:24), rank1 = replicate(24, ""),rank2= replicate(24, ""),
                       rank3= replicate(24, ""),     rank4= replicate(24, ""),
                       rank5= replicate(24, ""),   rank6= replicate(24, ""),
                       rank7= replicate(24, ""), rank8= replicate(24, ""),
                       rank9= replicate(24, ""), rank10= replicate(24, ""),
                       rank11= replicate(24, ""),     rank12= replicate(24, ""),
                       rank13= replicate(24, ""),     rank14= replicate(24, ""),
                       rank15= replicate(24, ""),     rank16= replicate(24, ""),
                       rank17= replicate(24, ""),rank18= replicate(24, ""),rank19= replicate(24, "")
                       )


#not sure how to make the initial DF
#replicate 24 rows with 19 cols
iterations = 24
variables = 20
DF.permutations.sc <- matrix(ncol=variables, nrow=iterations)
colnames(DF.permutations.sc) <- c("1", "rank1", "rank2", "rank3", "rank4", "rank5",
                               "rank6","rank7","rank8","rank9","rank10","rank11",
                               "rank12","rank13","rank14","rank15","rank16",
                               "rank17","rank18","rank19" )

#permutations -- for SC


#permutations without accounting for rank
its = 24
varis = 20
DF.permutations.no_rank <- matrix(ncol=varis, nrow=its)
#colnames(DF.permutations.sc) <- c("1", "rank1", "rank2", "rank3", "rank4", "rank5",
#                               "rank6","rank7","rank8","rank9","rank10","rank11",
#                               "rank12","rank13","rank14","rank15","rank16",
#                               "rank17","rank18","rank19" )

#ROW IS FIRST
for(row.num in 1:24){
  #print(c(row.num, "rowis") )
  for(col.num in 2:ncol(DF.permutations.sc) ){
  rand.rank.sc <- sample(male.whole.cell$SC.length[male.whole.cell$rank == col.num-1], 1, replace = FALSE)
  #print(SCll)   
  DF.permutations.sc[row.num,col.num] <- rand.rank.sc
   }
  }#yes this finally works!!!!
DF.permutations.sc <- as.data.frame(DF.permutations.sc)


#pair with real within cell SC variance
for( o in 1:nrow(DF.permutations.sc) ) {
  DF.permutations.sc$var_sc[o] <- var(as.numeric(DF.permutations.sc[o,2:20]))
  }




for(row.num in 1:24){
  #print(c(row.num, "rowis") )
  for(col.num in 2:ncol(DF.permutations.no_rank) ){
  rand.sc <- sample(male.whole.cell$SC.length[male.whole.cell$rank == col.num-1], 1, replace = FALSE)
  #print(SCll)   
  DF.permutations.no_rank[row.num,col.num] <- rand.sc
   }
  }#yes this finally works!!!!
DF.permutations.no_rank <- as.data.frame(DF.permutations.no_rank)

for( o in 1:nrow(DF.permutations.sc) ) {
  DF.permutations.no_rank$var_rand.sc[o] <- var(as.numeric(DF.permutations.no_rank[o,2:20]))
  }

```

```{r per.co.count, echo=FALSE, eval=FALSE}
#I don't think ... I end up useing these (matrics / DFs)
iterations = 24
variables = 20
DF.permutations_CO.count <- matrix(ncol=variables, nrow=iterations)
colnames(DF.permutations_CO.count) <- c("1", "rank1", "rank2", "rank3", "rank4", "rank5",
                               "rank6","rank7","rank8","rank9","rank10","rank11",
                               "rank12","rank13","rank14","rank15","rank16",
                               "rank17","rank18","rank19" )

for(row.num in 1:24){
  
  #print(c(row.num, "rowis") )
  for(col.num in 2:ncol(DF.permutations_CO.count) ){
  
  rand.rank.co <- sample(male.whole.cell$hand.foci.count[male.whole.cell$rank == col.num-1], 1, replace = FALSE)
  #print(SCll)   
  DF.permutations_CO.count[row.num,col.num] <- rand.rank.co
   }
  }
DF.permutations_CO.count <- as.data.frame(DF.permutations_CO.count)


#no rank - iterate / permute the sampling X times
its = 24
varis = 20
DF.permutations.CO.no_rank <- matrix(ncol=varis, nrow=its)

#make LIST of X DATAFRAMES

for(row.num in 1:24){
  #print(c(row.num, "rowis") )
  for(col.num in 2:ncol(DF.permutations.CO.no_rank) ){
  rand.co <- sample(male.whole.cell$hand.foci.count, 1, replace = FALSE)
  #print(SCll)   
  DF.permutations.CO.no_rank[row.num,col.num] <- rand.co
   }
  }#yes this finally works!!!!
DF.permutations.CO.no_rank <- as.data.frame(DF.permutations.CO.no_rank)

#
for( o in 1:nrow(DF.permutations.CO.no_rank) ) {
  DF.permutations.CO.no_rank$var_rand.co[o] <- var(as.numeric(DF.permutations.CO.no_rank[o,2:20]))
  }
```


