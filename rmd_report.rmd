---
title: "MLH1 data report "
author: "April Peterson"
date: "August 29, 2017"
output: github_document
---


```{r setup, echo=FALSE, include = FALSE}
library(knitr)
library(ggplot2)
library(pwr)
library(plyr)
library(lattice)
library(dplyr)
setwd("C:/Users/alpeterson7/Documents/MLH1repo")
load(file="MLH1_data_setup.RData")
```

#### Research Discription
Measure nMLH1 foci per meiotic cell to estimate recombination rate for diverse strains of house mice (rodents). Comparisons the differences in recombination rates across sexes and genetic background to inform models of how meiotic recombination rates evolve. (insert small picture of meixyte)

#### Discription of Report

- Display plots and figures of distributions of MLH1 counts to assess intial overall patterns.

-  *Report basic statistics of results and to help keep track of the number of images for each category and mouse*

#### Discription of quantification process

Aquired microscope cell images are quantified in batches after being anonimzed. The number of MLH1 foci, number of "achiasmate" and asynasped bivalents are quantified. A quality score is given; 1 to 5 (best to worst).

```{r, echo=FALSE, include = FALSE}
##FIX ORDER HERE (this should be put in the data setup script)
MLH1_data$strain<- factor(MLH1_data$strain,levels =c("G", "LEWES",
                              "WSB", "PWD","MSM","CAST"), order=T )
#order the data frame
MLH1_data <- with(MLH1_data, MLH1_data[order(sex, strain),])
#set the order of another column, based on another variable (so that when)

MLH1_data <- MLH1_data %>%
  arrange(strain, sex, mouse) %>%
  mutate(file.name = factor(file.name)) #another category that you want the order to match
# sort your dataframe, by the focal categories
MLH1_data$mouse <- factor(MLH1_data$mouse, levels=unique(MLH1_data$mouse))

#Add fake CAST female data
last_row <-data.frame(file.name=c("12dec18_20dec20_CAST_f1_sp1_12_1_rev.tif", "12dec18_20dec20_CAST_f1_sp1_12_2_rev.tif"), Random.Name = c("1234567.tif","123456789.tif"), quality=c(1,1),nMLH1.foci =c(25,22), XY.paired =c("no","no"), REDO.crop =c("no","no"),n =c(20,20), achiasmate=c(0,0),asynased=c(0,0),notes=c("",""),category = c("CAST female","CAST female"), strain= c("CAST","CAST"), sex=c("female","female"),adj_nMLH1.foci=c(25,22),mouse=c("20dec20_CAST_f1","20dec20_CAST_f1") )

MLH1_data <- rbind(MLH1_data, last_row)

#count the non-quality measures,  #remove non qualit
#length(MLH1_data[ !(is.na(MLH1_data$quality) | MLH1_data$quality==""), ] )  #15 rows with out quality scores, remove.
MLH1_data <- MLH1_data[ !(is.na(MLH1_data$quality) | MLH1_data$quality==""), ]

MLH1_by_F_strain <- MLH1_data[MLH1_data$sex == "female", ]
MLH1_by_M_strain <- MLH1_data[MLH1_data$sex == "male", ]
```

#### Mice table

Table of the number of mice used and MLH1 stats. (made with kable).

```{r, fig.height=2, fig.width=4, echo=FALSE}
#this table is saved in the .RData file
#use kable to make tables. warning this might not work for github Rmd.
kable(AP_strain_table)
```




#### Initial Patterns from MLH1 distributions

```{r first boxplots, echo=FALSE, fig.align='center'}
ff <- ggplot(MLH1_data, aes(x = as.factor(mouse), y = adj_nMLH1.foci)) + geom_boxplot(data = MLH1_data, aes(fill = factor(strain) ) ) + ggtitle("Boxplots of MLH1 distributions by mouse") + theme(axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank()) + scale_fill_manual(values=c("#56B4E9", "cadetblue", "lightblue",  "coral1", "#E69F00", "yellowgreen"))
ff <- ff + facet_wrap(~ sex, scales="free")
ff
```

After taking the data from 2 highest cell quality, some but not all mouse means converge.

```{r, histogram, echo=FALSE, fig.caption= "histograms", warning=FALSE, fig.align='center'}

histM <- ggplot(MLH1_data,(aes(adj_nMLH1.foci))) + xlim(c(16, 38))
histM <- histM + geom_histogram(stat = "bin", binwidth = 1)
histM <- histM + facet_wrap(~ category)
histM
```



```{r high qual, fig.caption="boxplots of MLH1 distributions", fig.height=5, fig.width=5, echo=FALSE, warnings=FALSE}

#MLH1_data$quality <- as.numeric(MLH1_data$quality) #this needs to be run for the subsetting to work

highest_qual_df <-  subset(MLH1_data, as.numeric(MLH1_data$quality) <= 2 )

qq <- ggplot(highest_qual_df, aes(x = mouse, y = adj_nMLH1.foci)) + geom_boxplot(data = highest_qual_df, aes(fill = factor(strain) ) ) +  ggtitle("Cells with quality scores of 2 or 1") +
  theme(axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank()) + scale_fill_manual(values=c("#56B4E9", "cadetblue", "lightblue",
  "coral1", "#E69F00", "yellowgreen"))
high_qual_boxplot <- qq + facet_wrap(~ sex, scales="free") #this is breaking the kniting... 
```




```{r, passing mice, echo=FALSE}
q_cutoff_table <- ddply(MLH1_data, .(mouse), summarise,
                        total =  length(adj_nMLH1.foci),
                        q5 = sum(as.numeric(quality) >= 4, na.rm = TRUE ), 
                        above5 = sum(as.numeric(quality) <= 4, na.rm = TRUE )
                       # q_l3 = sum(as.numeric(as.numeric(quality)) <= 4, na.rm = TRUE )
)
#q_cutoff_table
passed_mice <- as.vector(q_cutoff_table[q_cutoff_table$above5 > 15,]$mouse)

not_passed <- as.vector(unique(MLH1_data[!(unique(MLH1_data$mouse) %in% passed_mice),]$mouse) )

#mnake dataframe with just passing mice -- so that it can be ploted
passed_mice_df <- MLH1_data[ (as.numeric(MLH1_data$quality) < 5), ]
```

#### Comparison of MLH1 distributions


```{r,  show boxplots, fig.height=5, fig.width=8, echo=FALSE}
ff
high_qual_boxplot
```

After taking the data from 2 highest cell quality, some but not all mouse means converge. For some mice (mostly female) the majority of cells are excluded. This is especially true for PWD and WSB females.


#### Tests for quality and nMLH1 foci number

> *How do the distributions change across different quality scores?*

> *How do the distributions change across mice with a good number of cells?*


##### Effects of quality

Human quantification seems to be biased towards rating cells with more MLH1 foci as higher quality. Unbiased cell quality assignment, would not show a positive correlation with quality and nMLH1. (CAST female data is fake)

```{r, scatter plots of nMLH1 by score, echo=FALSE, fig.cap="caption"}
#make lattice / plots seperated by strain and sex
#facet

#quality scores are now 1:7?
qual_means <- MLH1_data %>% 
        group_by(category, quality) %>% 
        summarise(
          adj_nMLH1.foci = mean(adj_nMLH1.foci)
        )

p <- ggplot(MLH1_data,(aes(adj_nMLH1.foci,quality)))
p <- p + geom_point(stat = "identity")
p <- p  + geom_point(data = qual_means, colour="red") 
p <- p + facet_wrap(~ category)
p

```

I ploted the mean of each quality bin with a red dot. From the pattern of the red dots, there is definately a negative relationship with quality and nMLH1 foci across the data. This is most pronounced in MSM males and least pronounced in G males. The CAST female data is dummy data.


#### Assessing the Distributions by mouse

latice plot of scatter plots for jitter plots of cell oberservations by quality. The category mean is in black and the mouse specific mean is in red.
```{r, echo=FALSE, include=FALSE, message=FALSE, warning=FALSE}
#TODO, add a line for mouse and strain

#this creates a slot for CAST female, but no data
#each of the indiviual dataframes can be acessed with df_list$ ---- category
# for each sub-data frame, make mouse specific table,
#
#add mouse mean to the df
df_list <- split(MLH1_data, as.factor(MLH1_data$category))

o=0
i=0

for(i in 1:(length(df_list))){
 # print(i)
  df_list[[i]] <- df_list[[i]][!(is.na(df_list[[i]]$quality) | df_list[[i]]$quality==""), ]
  sub_mouse_means <- ddply(df_list[[i]], .(mouse), summarise,
                       mouse_nMLH1 = mean(adj_nMLH1.foci)
  )
 # print(sub_mouse_means)
  #below should work -- I think I need to go througheach row of the df_list[[i]]
  for(o in 1:length(df_list[[i]]$file.name)){
    df_list[[i]]$mouse_mean_MLH1[o] <- sub_mouse_means$mouse_nMLH1[ (df_list[[i]]$mouse[o] == sub_mouse_means$mouse) ]
        }
}
#remove CAST, this column isn't added to MLH1 col, it's added to df_list
#The above adds a column of mouse specific averages to a giant list of dataframes. Each dataframe in the list is specific to a category.
#the next step is to make plots from this giant list of dataframes
# I can delete all of the code below that by hand makes 

### not make a loop for ggplot... or giant ggplot base that uses latice smartly
# make new ggplots -- that are replaces

plot_list = list()
for (h in 1:length(df_list)) {
  pf <- ggplot(df_list[[h]],(aes(y= adj_nMLH1.foci, x= quality)))
  pf <- pf + geom_point(stat = "identity")+ geom_jitter()
  pf <- pf + geom_hline(yintercept = c( mean(df_list[[h]]$adj_nMLH1.foci) ), color="black" )
  pf <- pf + facet_wrap(~ mouse) + geom_hline(aes(yintercept = mouse_mean_MLH1), color="red")
  plot_list[[h]] =   pf
}

#aes must be same length --- 
# the last one is correct....?

#so plot list is some wride dataframe, but indeces 1:12 in plot list are ggplots
```


```{r, echo=FALSE, message=FALSE,results='hide', warning=FALSE }
#geom_hline(aes(yintercept = med, group = gr), colour = 'red')
for (gg in 1:length(plot_list) ){
  show(plot_list[gg])
  #invisible(lapply(obj,function(x) plot(x,main="some plot")))
}
```

Making all of these scatter plots, allows us to look at the whole distributions of the data for each mouse. The distance of the red line from the black could be a indicator of slides or mice with slide specific technical noise.

PWD females and a very large range. This is driven by data from 17apr15_PWD_f4. These data should be looked at more closely.

In some mice there seems to be bimodel cell populations, those of clearly high quality and those of lower quality. This may be due to the screening of images before quantification, and allowing more bad cells data remain in the data set, instead of deleting them.

#### Power Calculations

Main questions to address:
 
 > *How many cells per mouse should be sampled?*
 
 > *How many mice per strain should be sampled?*

Outline discription of the loop for comparing sample size effects

i) take ~100 independant samples of total images across different sample sizes (10%, 25%, 50%, 75%, 90%)
ii) then run t.tests across those samples, and report the p value 
iii) make a table of the p values for these sample permutations
iv) plot the p values or mean p values across sample sizes

Currently this section is under construction.
```{r}
colnms = c("mouse", "rep")
ply_data <- df.pasd.mice[df.pasd.mice$mouse == "8oct14_PWD_f8",]
#make this the function that I apply over the mice in the data

#simplify the t.test
t.test(sample(ply_data$nMLH1.foci, 5), sample(ply_data$nMLH1.foci, 5))$p.value
t.test(sample(ply_data$nMLH1.foci, 13), sample(ply_data$nMLH1.foci, 13))$p.value

#repeat the sampling 100 times
bb <-ddply(jj, .(mouse), function(x) t.test(x[1,2:5],x[2,2:5])$p.value )#t.test for 2 

#try with do
blah <- df.pasd.mice %>% group_by(mouse) %>% do(head(.))

plist=data.frame(pv=as.numeric(), mean1=as.numeric(), mean2=as.numeric())

hundred <- function(x){
  plist=data.frame(pv=as.numeric(), mean1=as.numeric(), mean2=as.numeric())
  for(eye in 1:100){
    samp1 = sample(x, 5)
    samp2 = sample(x, 5)
    plist$pv[eye] <- t.test(samp1,samp2)$p.value
    plist$mean1[eye] <- mean(samp1)
    plist$mean2[eye] <- mean(samp2)
  }
  return(plist)
} 
mm <- hundred(ply_data$nMLH1.foci)


#makes dfs, with the samples. // sampling from MLH1
permut.mouse.numb <- function(x, rep_size, samp_size){
  new.df = matrix(nrow=rep_size, ncol=samp_size)
for(i in 1:rep_size) {
  new.df[i,] = sample(x, samp_size)
  }
return(as.data.frame(new.df, colnames(colnms) ) )
  #return sampled
}
#can I integrate the sampling and t.test here?

#function for 

#this works. sampling x permutations, y sample size
vv <- permut.mouse.numb(df.pasd.mice$nMLH1.foci,5,4)

## I think this does it! this makes a list of 23 dfs (for each mouse in the large df)
##this makes dfs for doing the t.tests
kk<-dlply(df.pasd.mice, .(mouse), function(x) permut.mouse.numb(x$nMLH1.foci,2,5) )
#applies permut function over mouse -- then run a t.test and return pvalue
jj<-ddply(df.pasd.mice, .(mouse), function(x) permut.mouse.numb(x$nMLH1.foci,2,20) )

#
pval <- function()

#t.test and p values
#maybe I should just choose 2 samples, do a t.test, do that 100 times..?
#below runs t.tests on
#this is making a new tab;e, 
bb <- ddply(jj, .(mouse), function(x) t.test(x[1,2:5],x[2,2:5])$p.value )#t.test for 2 samples of size 20

# figure out a way to mush dd into a matrix

repeats = 10
new.p.matrix = matrix(ncol=length(unique(jj$mouse)), nrow = repeats)
for(e in 1:repeats){
  new.p.matrix[e]<- ddply(jj, .(mouse), function(x) t.test(x[1,2:5],x[2,2:5])$p.value )

  }

powrange <- seq(0.4, .9, .1)
n <- sapply(powrange, function(i) power.prop.test(p1=0.4,p2=0.24,power=i,sig.level=0.05)$n)
plot(powrange, n)


bb$mouse[(bb$V1 < 0.05)]
#mice which had significantly difference in samples of size 20
#16jan16_G_f2  20feb16_G_f3  3nov15_WSB_f1
#17mar16_G_f1
#16jan16_G_f2   20dec16_LEW_m3
#30sep16_MSM_f2
#22jun15_G_m2

#figure out how to permute these tests. repeat the above... then return distributions of p values

#10
#20feb16_G_f3   13nov16_MSM_m1

#figure out a way to plot/visualize these pvalues
#2 samples are good for t.tests, but I need to repeat 100 times
#I think I need to ... add the replicates that can be xxply through

## for 1:100, cal permt(10,2) then call 
ll=c()
ty <- for(i in 1:10){
  print(i)
  jj <-ddply(df.pasd.mice, .(mouse), function(x) permut.mouse.numb(x$nMLH1.foci,2,10) )
  
  bb <-ddply(jj, .(mouse), function(x) t.test(x[1,2:5],x[2,2:5])$p.value )
  #the t.test$p.values are not exactly what they should be
#put p values into a list? (100 pvalues )
  ll[i] = bb$V1[i]#this returns a list of p values for different mice? one mouse?
}

#for 

gg<-t.test(kk$`10mar15_PWD_m2`[1,2:5], kk$`10mar15_PWD_m2`$V3)  
#jj$`10mar15_PWD_m2`
#jj[1,1:5]
#$`10mar15_PWD_m2`
#[1] 0.6071011

##then do t.test to test the distributions 
## data is the data frames, by mouse, function is t.test


# use q_cut_off table, to find the mice to use
listOmice <- q_cutoff_table$mouse[ (q_cutoff_table$total >= 25) ]
#mke new df with from 
df.pasd.mice <- MLH1_data[MLH1_data$mouse %in% listOmice, ]

#write function --- for taking 100 samples of 10
permut.df <- function(df){
  #semperate by mouse
    mouse.data    <- ddply(df, c("mouse"), summarise,
       df <- data.frame(
              samp = sample(nMLH1.foci,5)
            ) 
        )
    
  return(mouse.data)
}

mouse.data <- ddply(df.pasd.mice, c("mouse"), summarise,
          
  m.df <- data.frame(sample(nMLH1.foci, 5, replace = FALSE) )
  )



# this creates dataframe, which is a subset of larger dataframe ... not sure se_alone, but samples 40 of 
this =ddply (df.pasd.mice, .(mouse), subset, sample(seq_along(nMLH1.foci)<=5))
#ss <- sample(df.pasd.mice$nMLH1.foci)

Table_BD_mouse <- ddply(BDMLH1_data, c("ANIMAL_ID", "Cross"), summarise,
                       N  = length(nMLH1_foci),
                       mean_co = format(round( mean(nMLH1_foci), 3), nsmall = 3),
                       var = format(round( var(nMLH1_foci),3), nsmall = 3),
                       sd   = round(sd(nMLH1_foci),3),
                       se   = round(sd / sqrt(N),3)
                       #text=paste(Cross, collapse=""))
)

```



```{r, include=FALSE}
passed_mice_data <- MLH1_data[MLH1_data$mouse %in% passed_mice, ]
non_passed_mice_data <- MLH1_data[MLH1_data$mouse %in% not_passed, ]

#make a column to mark if observation comes from passed or not passed mouse
#turn this into boxplot and sort the category order, otherwise it's hard to any patterns
sc <- qplot(mouse, nMLH1.foci,  colour = category, data = non_passed_mice_data, main="s", xlab="s", ylab="es")
#sc + theme(legend.position="none")

sc <- qplot(mouse, nMLH1.foci,  colour = category, data = passed_mice_data, main="s", xlab="s", ylab="es")
#sc + theme(legend.position="none")

# not working not sure of the purpose
#count =1
#for(i in MLH1_data$file.name){
#  templist= strsplit(i, split="_")[[1]]
#  if(MLH1_data$mouse %in% passed_mice) 
#  MLH1_data$mouse[count] <- c
#  count= count +1
#}
```